<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Alloha</title>

    <!-- Open Graph Meta Tags -->
    <meta property="og:title" content="Alloha - Fun and Challenging Grid Game" />
    <meta property="og:description" content="Play Alloha, a fun and challenging grid matching game with exciting power-ups and multiple editions." />
    <meta property="og:image" content="https://abhimanyulodha.github.io/alloha/images/alloha-og-image.svg" />
    <meta property="og:url" content="https://abhimanyulodha.github.io/alloha/" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="Alloha Game" />
    
    <!-- Twitter Card Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Alloha Game - Fun and Addictive Grid Game" />
    <meta name="twitter:description" content="Play Alloha, a fun and challenging grid matching game with exciting power-ups and multiple editions." />
    <meta name="twitter:image" content="https://abhimanyulodha.github.io/alloha/images/alloha-og-image.svg" />

    <!-- Existing styles/scripts below -->
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <script src="https://cdn.tailwindcss.com"></script>

    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@300..700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: linear-gradient(135deg, #FDFCFB 0%, #E2D1C3 100%);
            --card: rgba(255, 255, 255, 0.85);
            --text: #5D4037;
            --text-secondary: #8D6E63;
            --accent: #E57373;
            --accent-light: rgba(229, 115, 115, 0.1);
            --accent-gradient: linear-gradient(135deg, #E57373 0%, #FF8A65 100%);
            --accent-gradient-shaded: linear-gradient(135deg, #EE9A9A 0%, #FFCCBC 100%);
            --highlighted-bg: rgba(229, 115, 115, 0.15);
            --highlighted-border: rgba(229, 115, 115, 0.3);
            --grid-cell-bg: #FAF8F5;
            --toggle-bg-inactive: #E0E0E0;
            --stuck-block: linear-gradient(135deg, #757575 0%, #616161 100%);
            --glass-border: rgba(255, 255, 255, 0.2);
            --faint-border: rgba(0, 0, 0, 0.08);
            --shadow-soft: 0 4px 15px rgba(0, 0, 0, 0.05);
            --shadow-medium: 0 8px 30px rgba(0, 0, 0, 0.07);
            --shadow-strong: 0 15px 50px rgba(0, 0, 0, 0.09);
            --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            --ease-quick: cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        @keyframes gradient-pan {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        body {
            font-family: 'Quicksand', sans-serif;
            font-weight: 500;
            background: var(--bg);
            color: var(--text);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: background 0.3s ease-in-out;
            background-size: 400% 400%;
            animation: gradient-pan 20s ease infinite;
        }
        body.modal-open {
            overflow: hidden;
        }
        .themed-button {
            font-weight: 600; border-radius: 12px; transition: all 0.3s var(--ease-smooth);
            border: none; position: relative; overflow: hidden; transform-origin: center;
        }
        .themed-button:hover { transform: translateY(-2px); box-shadow: var(--shadow-medium); }
        .themed-button:active { transform: scale(0.98); transition-duration: 0.1s; }
        
        .glass-card {
            background: var(--card);
            backdrop-filter: blur(20px) saturate(180%); -webkit-backdrop-filter: blur(20px) saturate(180%);
            box-shadow: var(--shadow-soft), 0 0 0 1px var(--glass-border), inset 0 1px 0 rgba(255, 255, 255, 0.3); border: none !important; transition: all 0.3s var(--ease-smooth); position: relative; overflow: hidden;
        }
        .enhanced-shadow {
            box-shadow: var(--shadow-medium), 0 0 0 1px var(--glass-border), inset 0 1px 0 rgba(255, 255, 255, 0.3) !important;
        }
        .grid-cell {
            aspect-ratio: 1; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: clamp(1.2rem, 5.5vw, 2.75rem);
            transition: all 0.3s var(--ease-smooth); background: var(--grid-cell-bg);
            border: 1px solid rgba(0, 0, 0, 0.04);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.02);
            position: relative; overflow: hidden; min-width: 40px; min-height: 40px;
        }
        .grid-cell:hover:not(.highlighted):not(.stuck-cell):not(.score-display-cell) {
            transform: scale(1.03);
            box-shadow: 0 0 12px rgba(0,0,0,0.1);
            z-index: 2;
        }
        .themed-modal { border-radius: 20px; background: var(--card); box-shadow: var(--shadow-strong); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); }
        
        #new-game-btn, #confirm-restart-btn, #play-again-btn, #close-warning-btn, #close-unlock-btn { background: var(--accent-gradient); }
        #select-edition-btn { background: var(--accent-gradient-shaded); }

        .progress-bar-container { position: relative; overflow: hidden; background: var(--accent-light); border-radius: 9999px; }
        .progress-bar-fill { background: var(--accent-gradient); position: relative; overflow: hidden; transition: width 0.3s var(--ease-smooth); height: 100%; }
        .progress-bar-fill::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.6) 50%, transparent 100%); animation: progress-shimmer 2s infinite; }
        @keyframes progress-shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }

        @keyframes dice-tumble {
            0%   { transform: rotate(0deg) scale(1); filter: blur(0px); }
            25%  { transform: rotate(-90deg) scale(1.05); }
            50%  { transform: rotate(-180deg) scale(1.1); filter: blur(3px); }
            75%  { transform: rotate(-270deg) scale(1.05); }
            100% { transform: rotate(-360deg) scale(1); filter: blur(0px); }
        }
        .dice-tumble { animation: dice-tumble 0.6s var(--ease-bounce); }
        .shake-animation { animation: shake 0.4s ease-in-out; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px) rotate(-3deg); } 75% { transform: translateX(5px) rotate(3deg); } }

        .modal { transition: all 0.3s var(--ease-smooth); }
        .modal.is-open { opacity: 1; visibility: visible; }
        .modal-content { transition: all 0.3s var(--ease-smooth); }
        .modal.is-open .modal-content { transform: scale(1) translateY(0); }
        
        .superpower-btn { position: relative; background: transparent; border: none; box-shadow: none; color: var(--text-secondary); font-weight: 500; border-radius: 12px; padding: 4px; font-size: 0.7rem; text-align: center; transition: all 0.3s ease; cursor: pointer; min-width: 50px; line-height: 1.2; }
        .superpower-btn:hover:not(:disabled) { transform: translateY(-2px); text-decoration: underline; background: var(--accent-light); }
        .superpower-btn--active { font-weight: 700; transform: translateY(-2px) !important; background: var(--accent-light); }
        .superpower-btn:disabled { opacity: 0.5; cursor: not-allowed; text-decoration: none; }
        
        #close-rules-btn, #close-game-over-btn, #close-edition-select-btn, #confirm-cancel-btn { color: var(--text-secondary); }
        #close-rules-btn:hover, #close-game-over-btn:hover, #close-edition-select-btn:hover, #confirm-cancel-btn:hover { color: var(--text); background-color: var(--accent-light); }
        
        .score-display-cell { 
            background: var(--grid-cell-bg) !important; 
            color: var(--text-secondary);
            font-size: clamp(1rem, 4vw, 1.5rem);
        }
        .highlighted { 
            background-color: var(--highlighted-bg); 
            border: 1px solid var(--highlighted-border);
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.2); 
            animation: pulse-highlight 2s infinite; 
        }
        @keyframes pulse-highlight { 0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4); } 70% { box-shadow: 0 0 0 4px rgba(76, 175, 80, 0); } 100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); } }
        
        .alloha-logo { 
            width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;
            animation: pulse-logo 4s infinite ease-in-out;
        }
        .alloha-logo svg { width: 100%; height: 100%; }
        .alloha-logo svg path, .alloha-logo svg g { fill: var(--accent) !important; }

        #mode-toggle-switch { transition: background-color 0.2s ease-in-out; background-color: var(--toggle-bg-inactive); }
        #mode-toggle-switch.time-burst-active { background-color: var(--accent); }
        #mode-toggle-switch.time-burst-active #mode-toggle-thumb { transform: translateX(1.5rem); }
        #timer-display { font-variant-numeric: tabular-nums; transform: translateZ(0); }
        
        #edition-options, #rules-modal .space-y-4 {
             -webkit-overflow-scrolling: touch;
        }
        #edition-options::-webkit-scrollbar { width: 8px; }
        #edition-options::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); border-radius: 4px; }
        #edition-options::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 4px; }
        #edition-options::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.3); }

        .edition-selected { background-color: var(--accent-light) !important; font-weight: 700; color: var(--accent); }

        @keyframes shimmer-text-anim {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }
        .shimmer-text {
            background: linear-gradient(90deg, var(--toggle-bg-inactive), white, var(--toggle-bg-inactive));
            background-size: 200% auto;
            color: transparent;
            background-clip: text;
            -webkit-background-clip: text;
            animation: shimmer-text-anim 2.5s linear infinite;
        }

        .confetti-piece {
            position: absolute; width: 8px; height: 16px; background: var(--accent); top: -20px;
            opacity: 0; animation-timing-function: linear;
        }
        @keyframes confetti-fall {
            0% { top: -20px; opacity: 1; transform: rotate(0deg); }
            100% { top: 100%; opacity: 1; transform: rotate(720deg); }
        }
        
        @keyframes pulse-faint {
            0%, 100% { transform: scale(1); box-shadow: var(--shadow-soft); }
            50% { transform: scale(1.02); box-shadow: var(--shadow-medium); }
        }
        #select-edition-btn { animation: pulse-faint 3s infinite ease-in-out; }
        @keyframes pulse-logo {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .stuck-cell {
            background-image: var(--stuck-block) !important;
            color: white; font-size: clamp(1rem, 4vw, 2rem) !important;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        .golden-placement-option {
            cursor: pointer; box-shadow: 0 0 0 4px gold, inset 0 0 10px gold;
            background-color: rgba(255, 215, 0, 0.2); animation: pulse-faint 1.5s infinite;
        }
        @keyframes bob-animation {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        .bob-animation { animation: bob-animation 2s ease-in-out infinite; }
        
        @keyframes twinning-flash {
            0%, 100% { background-color: var(--highlighted-bg); }
            50% { background-color: var(--accent); }
        }
        .twinning-flash-animation { animation: twinning-flash 1.5s ease-in-out; }

        .tutorial-progress-dot {
            width: 0.5rem; height: 0.5rem; border-radius: 9999px; background-color: var(--accent-light);
        }
        .tutorial-progress-dot.active {
            background-color: var(--accent);
        }

        .valid-placement { box-shadow: 0 0 0 1px rgba(229, 115, 115, 0.3) !important; transform: scale(1.02) !important; }

        @keyframes score-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.5); }
            50% { transform: scale(1.1); box-shadow: 0 0 0 6px rgba(255, 215, 0, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }
        .score-pulse-animation {
            animation: score-pulse 0.8s ease-in-out; z-index: 10;
        }

        .floating-score {
            position: fixed;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            z-index: 100;
            pointer-events: none;
            animation: float-to-score 1.2s ease-in forwards;
        }
        @keyframes float-to-score {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-80px) scale(0.5); }
        }

        .sparkle {
            position: fixed;
            width: 8px;
            height: 8px;
            background: #FFD700;
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            animation: sparkle-anim 0.7s ease-out;
        }
        @keyframes sparkle-anim {
            0% { opacity: 1; transform: scale(0.5) translate(0, 0); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: scale(1.5) translate(var(--sparkle-x), var(--sparkle-y)); }
        }

        .hero-block-hint::before {
            content: var(--hero-symbol);
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: var(--accent);
            opacity: 0.12;
            z-index: 0;
            text-shadow: 0 0 6px var(--accent);
            animation: hero-pulse 3s ease-in-out infinite;
        }

        @keyframes hero-pulse {
            0%, 100% { 
                opacity: 0.12;
                transform: scale(1);
            }
            50% { 
                opacity: 0.22;
                transform: scale(1.02);
            }
        }
        
        .curse-overlay {
            position: fixed;
            font-size: 3rem;
            pointer-events: none;
            z-index: 1000;
            animation: curse-overlay-anim 0.7s ease-out forwards;
            text-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        @keyframes curse-overlay-anim {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.2); opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        
        #total-score, #high-score, #final-score-modal, #high-score-modal {
            line-height: 1.2;
        }

        .unlock-hint {
            font-size: 0.7rem;
            font-weight: 500;
            color: var(--text-secondary);
            margin-top: -2px;
        }
        
        .badge-item {
            cursor: pointer;
            transition: transform 0.2s ease;
        }
        .badge-item:hover {
            transform: scale(1.1);
        }
        .badge-item.locked {
            filter: grayscale(100%);
            opacity: 0.5;
        }
        .badge-item .badge-emoji {
            font-size: clamp(2.5rem, 10vw, 3.5rem);
            line-height: 1;
        }
        .badge-item .badge-name {
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 0.5rem;
            /* FIX 2: Added styles for Badge Share image */
            text-align: center;
            min-height: 2.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .toast-notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translate(-50%, -150%);
            background: var(--card);
            color: var(--text);
            padding: 12px 24px;
            border-radius: 9999px;
            box-shadow: var(--shadow-strong);
            z-index: 1001;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: slide-in-out 3s ease-in-out forwards;
        }
        @keyframes slide-in-out {
            0% { transform: translate(-50%, -150%); }
            15% { transform: translate(-50%, 0); }
            85% { transform: translate(-50%, 0); }
            100% { transform: translate(-50%, -150%); }
        }
    </style>
</head>
<body class="p-2 lg:p-4">
    <audio id="audio-unlocker" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" preload="auto"></audio>
    <main id="game-container" class="w-full max-w-5xl mx-auto flex flex-col lg:flex-row gap-4 lg:gap-6 items-center lg:items-stretch pt-8 lg:pt-16">
        <div class="w-full lg:w-2/3 relative">
            <div id="effects-container" class="absolute inset-0 pointer-events-none z-10 overflow-hidden"></div>
            <div id="game-board-container" class="p-2 lg:p-6 h-full glass-card rounded-2xl">
                <div class="grid grid-cols-8 gap-1 lg:gap-3 h-full">
                    <div id="game-board" class="col-span-7 grid grid-cols-7 gap-1 lg:gap-2"></div>
                    <div id="row-scores-display" class="col-span-1 grid grid-rows-7 gap-1 lg:gap-2"></div>
                    <div id="col-scores-display" class="col-span-7 grid grid-cols-7 mt-1 lg:mt-0 gap-1 lg:gap-2"></div>
                    <div class="flex items-center justify-center">
                        <div class="alloha-logo">
                            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 396.75 396.749985" preserveAspectRatio="xMidYMid meet"><defs><clipPath id="864cd2432c"><path d="M 40 0 L 355 0 L 355 396.5 L 40 396.5 Z M 40 0 "/></clipPath></defs><g clip-path="url(#864cd2432c)"><g transform="matrix(1, 0, 0, 1, 40, 0)"><g><g transform="matrix(1, 0, 0, 1, 1, 0)"><g><g fill-opacity="1"><g transform="translate(0.873977, 194.870819)"><g><path d="M 137.910156 0 L 137.910156 -174.546875 L 6.804688 -174.546875 L 6.804688 0 L 50.503906 0 L 50.503906 -48.675781 L 94.207031 -48.675781 L 94.207031 0 Z M 94.207031 -88.449219 L 50.503906 -88.449219 L 50.503906 -134.507812 L 94.207031 -134.507812 Z M 94.207031 -88.449219 "/></g></g></g></g><g transform="matrix(1, 0, 0, 1, 146, 116)"><g><g fill-opacity="1"><g transform="translate(1.206642, 267.950498)"><g><path d="M 137.910156 0 L 137.910156 -174.546875 L 6.804688 -174.546875 L 6.804688 0 Z M 94.207031 -39.777344 L 50.503906 -39.777344 L 50.503906 -134.507812 L 94.207031 -134.507812 Z M 94.207031 -39.777344 "/></g></g></g></g></g><g transform="matrix(1, 0, 0, 1, 148, 0)"><g><g fill-opacity="1"><g transform="translate(0.26582, 194.870819)"><g><path d="M 137.386719 0 L 137.386719 -39.777344 L 50.503906 -39.777344 L 50.503906 -174.546875 L 6.804688 -174.546875 L 6.804688 0 Z M 137.386719 0 "/></g></g></g></g></g><g transform="matrix(1, 0, 0, 1, -0.000000000000007105, 116)"><g><g fill-opacity="1"><g transform="translate(1.876102, 267.950498)"><g><path d="M 137.910156 0 L 137.910156 -174.546875 L 94.207031 -174.546875 L 94.207031 -107.03125 L 50.503906 -107.03125 L 50.503906 -174.546875 L 6.804688 -174.546875 L 6.804688 0 L 50.503906 0 L 50.503906 -68.5625 L 94.207031 -68.5625 L 94.207031 0 Z M 137.910156 0 "/></g></g></g></g></g><g transform="matrix(1, 0, 0, 1, 242, 20)"><g><path fill-rule="nonzero" d="M 43.164062 120.25 L 0.375 120.25 L 0.375 0.414062 L 43.164062 0.414062 Z M 43.164062 120.25 "/></g></g><g transform="matrix(1, 0, 0, 1, 213, 20)"><g><path fill-rule="nonzero" d="M 0.839844 43.222656 L 0.839844 0.4375 L 63.683594 0.4375 L 63.683594 43.222656 Z M 0.839844 43.222656 "/></g></g></g></g></g></g></svg>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="w-full lg:w-1/3">
            <div id="scoring-panel" class="relative flex-1 flex flex-col gap-y-4 p-4 lg:p-6 glass-card rounded-2xl">
                
                <div class="glass-card enhanced-shadow rounded-2xl p-4 flex flex-col flex-1 min-h-0">
                    <div id="in-game-content-wrapper" class="flex-1 min-h-0 flex flex-col">
                        <div id="pre-game-content"></div>
                        <div id="in-game-content" class="flex-1"></div>
                    </div>
                </div>

                <div class="glass-card enhanced-shadow rounded-xl p-3">
                    <div class="relative w-full h-2.5 progress-bar-container">
                        <div id="progress-bar-fill" class="progress-bar-fill"></div>
                    </div>
                </div>

                <div class="glass-card enhanced-shadow rounded-2xl p-4">
                    <div class="flex justify-center items-center gap-3">
                        <button id="rules-btn" class="py-2 px-3 themed-button text-xs whitespace-nowrap" style="color: var(--accent); background: var(--accent-light);">Help</button>
                        <button id="new-game-btn" class="py-2 px-3 themed-button text-white text-xs whitespace-nowrap">New Game</button>
                        <button id="badges-btn" class="py-2 px-3 themed-button text-xs whitespace-nowrap" style="color: var(--accent); background: var(--accent-light);">Badges</button>
                    </div>
                    <div class="text-center mt-3">
                        <button id="select-edition-btn" class="w-full py-2 px-4 themed-button text-white text-sm flex items-center justify-center gap-2">
                            Select Game Edition
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                </div>
                
                <div class="glass-card enhanced-shadow rounded-2xl p-4 mt-auto">
                    <div class="grid grid-cols-2 gap-4 text-center">
                        <div>
                            <h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">Total Score</h3>
                            <div id="total-score" class="text-3xl font-bold" style="color: var(--accent);" aria-live="polite"></div>
                        </div>
                        <div>
                            <h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">High Score</h3>
                            <div id="high-score" class="text-3xl font-bold" style="color: #FFC107;" aria-live="polite"></div>
                        </div>
                    </div>
                    
                    <hr class="border-t my-4" style="border-color: var(--faint-border);">

                    <div class="grid grid-cols-3 gap-y-3 text-center">
                        <div class="border-r" style="border-color: var(--faint-border);">
                            <h3 class="text-xs font-semibold uppercase tracking-wider" style="color: var(--text-secondary);">Rows</h3>
                            <div id="rows-total-score" class="text-lg font-bold" aria-live="polite"></div>
                        </div>
                        <div class="border-r" style="border-color: var(--faint-border);">
                            <h3 class="text-xs font-semibold uppercase tracking-wider" style="color: var(--text-secondary);">Columns</h3>
                            <div id="cols-total-score" class="text-lg font-bold" aria-live="polite"></div>
                        </div>
                        <div>
                            <h3 class="text-xs font-semibold uppercase tracking-wider" style="color: var(--text-secondary);">Twinning</h3>
                            <div id="cross-total-score" class="text-lg font-bold" style="color: #FFC107;" aria-live="polite"></div>
                        </div>
                        <div class="border-r pt-3 border-t" style="border-color: var(--faint-border);">
                            <h3 class="text-xs font-semibold uppercase tracking-wider leading-tight" style="color: var(--text-secondary);">Grid<br>Bonus</h3>
                            <div id="bonus-grid-score" class="text-lg font-bold" style="color: #FFC107;" aria-live="polite"></div>
                        </div>
                        <div class="border-r pt-3 border-t" style="border-color: var(--faint-border);">
                            <h3 class="text-xs font-semibold uppercase tracking-wider leading-tight" style="color: var(--text-secondary);">Hero<br>Bonus</h3>
                            <div id="hero-bonus-score" class="text-lg font-bold" style="color: #FFC107;" aria-live="polite"></div>
                        </div>
                        <div class="pt-3 border-t" style="border-color: var(--faint-border);">
                            <h3 class="text-xs font-semibold uppercase tracking-wider leading-tight" style="color: var(--text-secondary);">Empty<br>Block</h3>
                            <div id="empty-block-penalty" class="text-lg font-bold" style="color: var(--text);" aria-live="polite"></div>
                        </div>
                    </div>
                </div>

            </div>
        </div>
    </main>

    <div id="rules-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-lg themed-modal p-6 transform scale-95 -translate-y-4">
            <div class="flex justify-between items-start mb-4">
                <div class="flex-grow">
                    <h2 id="rules-title" class="text-3xl font-bold" style="font-family: 'Pacifico', cursive; color: var(--accent);">How to Play Alloha</h2>
                    <p class="text-sm mt-2 font-bold" style="color: var(--text-secondary);">A fun & simple game by Abhimanyu Lodha</p>
                </div>
                <button id="close-rules-btn" aria-label="Close How to Play" class="w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold flex-shrink-0">×</button>
            </div>
            <div class="space-y-4 text-sm max-h-[70vh] overflow-y-auto pr-2" style="color: var(--text-secondary)">
                <h3 class="font-bold text-lg" style="color: var(--accent);">🎯 The Goal</h3>
                <p>Fill the 7x7 grid by placing pairs of 'Allohas' to create lines and patterns of matching symbols. Score the most points before the grid is full!</p>
                
                <h3 class="font-bold text-lg" style="color: var(--accent);">🕹️ How to Play</h3>
                <ol class="list-decimal list-inside space-y-1">
                    <li><b>Roll the Dice:</b> Click the '🎲' button to get your two Allohas for the turn.</li>
                    <li><b>Place Your Pair:</b> Place both Allohas in any two empty, adjacent (but not diagonal) squares on the grid.</li>
                    <li><b>Explore Editions:</b> Use the "Select Game Edition" button to discover different versions of the game. Achieve score goals to unlock new editions, each with a unique theme and "Twinning" scoring pattern!</li>
                </ol>

                <h3 class="font-bold text-lg" style="color: var(--accent);">👑 The Hero Symbol</h3>
                <p>At the start of each game, one symbol is chosen as the "Hero." You will see faint watermarks of this symbol on 7 random squares. Place the correct Hero Symbol on these squares to earn a <b>+2 Hero Bonus</b> each time!</p>
                
                <h3 class="font-bold text-lg" style="color: var(--accent);">✨ Superpowers</h3>
                <p>You can use <b>two different superpowers</b> once per game to get out of a tight spot!</p>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>Past Lives:</b> Undoes your most recent move (placing a pair of Allohas).</li>
                    <li><b>Bomb Bae:</b> Lets you clear any filled block (except Wild and Cursed blocks). Blocks above it will fall down to fill the space.</li>
                    <li><b>No Return:</b> Exchange any Alloha on the grid for a new one of your choice from the symbol set.</li>
                    <li><b>Swap Them:</b> Swap the positions of any two adjacent Allohas. This must be used <b>before</b> you roll the dice.</li>
                </ul>
                
                <h3 class="font-bold text-lg" style="color: var(--accent);">🎲 Special Blocks</h3>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>Wild Card (💎):</b> A powerful gem that acts as <b>any</b> Alloha to help you complete a line. It appears once per game.</li>
                    <li><b>Cursed Block (☠️):</b> An immovable obstacle that cannot be changed or removed by any superpower. It also appears once per game.</li>
                </ul>
            
                <h3 class="font-bold text-lg" style="color: var(--accent);">📈 Scoring & Bonuses</h3>
                <p>Points are awarded for creating lines of 3 or more matching Allohas in rows or columns.</p>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>3 in a line:</b> 3 points</li>
                    <li><b>4 in a line:</b> 5 points</li>
                    <li><b>5 in a line:</b> 8 points</li>
                    <li><b>6 in a line:</b> 12 points</li>
                    <li><b>7 in a line:</b> 20 points</li>
                </ul>
                <p>On top of that, you can earn big with these bonuses:</p>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>Twinning Bonus:</b> Create sequences on the special <b>highlighted pattern</b>. You score points for these lines <b>in addition</b> to their normal row or column score!</li>
                    <li><b>Grid Bonus:</b> Form a square of 2x2, 3x3, or larger with the same Alloha to earn bonus points equal to its size squared (e.g., a 2x2 grid gives 4 bonus points).</li>
                </ul>
                
                <h3 class="font-bold text-lg" style="color: var(--accent);">👑 The Golden Alloha</h3>
                <p>The game isn't over until the final move is made! When the grid is full or you can't make any more moves, you get to place one final <b>Golden Alloha</b>.</p>
                <ul class="list-disc list-inside space-y-1">
                    <li>You can choose <b>any symbol</b> from the game's set.</li>
                    <li>You can place it in <b>any available empty square</b> on the board. Make it count!</li>
                </ul>

                <h3 class="font-bold text-lg" style="color: var(--accent);">💣 Empty Block</h3>
                <p>After you place your Golden Alloha, any other spaces that are still empty will be filled with Stuck Blocks (💣). Each one contributes to the <b>Empty Block</b>, a penalty against your final score, so try to fill the grid completely!</p>

                <h3 class="font-bold text-lg" style="color: var(--accent);">Penalty</h3>
                <p>Be careful! Any row, column, or Twinning Pattern line that can no longer form a 3-symbol sequence will also receive a <b>-5 point penalty</b>.</p>
            
                <p class="pt-4 italic">Have fun. And if you have read till here, then DM @sonofarjuna for a free chocolate.</p>
            </div>
        </div>
    </div>
    
    <div id="edition-select-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm themed-modal p-6 transform scale-95 -translate-y-4">
            <div class="flex justify-between items-center mb-4">
                 <h2 class="text-2xl font-bold" style="color: var(--accent);">Select Edition</h2>
                 <button id="close-edition-select-btn" aria-label="Close Select Edition" class="w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            </div>
            <div class="flex items-center justify-center mb-4 space-x-4">
                <span id="classic-text" class="font-semibold" style="color: var(--text-secondary)">Classic</span>
                <div id="mode-toggle-switch" class="w-14 h-8 flex items-center rounded-full p-1 cursor-pointer">
                    <div id="mode-toggle-thumb" class="bg-white w-6 h-6 rounded-full shadow-md transform transition-transform"></div>
                </div>
                <span id="time-burst-text" class="font-semibold" style="color: var(--text-secondary)">Time Burst</span>
            </div>
            <div id="edition-options" class="flex flex-col gap-3 max-h-64 overflow-y-auto"></div>
        </div>
    </div>
    
    <div id="confirm-restart-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm themed-modal p-8 text-center transform scale-95 -translate-y-4">
            <h2 class="text-2xl font-bold mb-4" style="color: var(--accent);">Restart Game?</h2>
            <p class="mb-6" style="color: var(--text-secondary);">Your current progress will be lost. Are you sure?</p>
            <div class="flex justify-center items-center gap-3">
                <button id="confirm-cancel-btn" class="flex-1 py-2 px-4 themed-button text-sm" style="color: var(--text-secondary); background: rgba(0,0,0,0.05);">Cancel</button>
                <button id="confirm-restart-btn" class="flex-1 py-2 px-4 themed-button text-white text-sm">Restart</button>
            </div>
        </div>
    </div>

    <div id="game-over-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-md text-center themed-modal p-8 transform scale-95 -translate-y-4 relative flex flex-col">
            <button id="close-game-over-btn" aria-label="Close Game Over" class="absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-4xl font-bold mb-2" style="font-family: 'Pacifico', cursive; color: var(--accent);">Game Over Alloha!</h2>
            <p id="game-over-reason" class="text-lg mt-2 mb-4" style="color: var(--accent);"></p>
            <div id="final-score-modal" class="text-7xl font-bold my-8 flex-grow flex items-center justify-center" style="color: var(--accent);" aria-live="polite"></div>
            <div id="score-breakdown" class="mb-6 p-4 glass-card rounded-xl text-xs" style="display: grid;">
                <div class="grid grid-cols-2 gap-2">
                    <div class="text-left">Rows: <span id="final-rows-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Columns: <span id="final-cols-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Twinning: <span id="final-cross-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Bonus Grids: <span id="final-bonus-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Hero Bonus: <span id="final-hero-score" class="float-right font-bold">0</span></div>
                    <div class="text-left col-span-2 border-t pt-2 mt-2">Empty Block: <span id="final-penalty-score" class="float-right font-bold">0</span></div>
                </div>
            </div>
            <p>High score: <span id="high-score-modal" class="font-bold" style="color: #FFC107;" aria-live="polite">0</span></p>
            <div id="game-over-buttons" class="no-screenshot flex flex-col items-center gap-3 mt-6">
                <div class="flex w-full items-center gap-3">
                    <button id="play-again-btn" class="flex-1 themed-button text-white font-bold py-3 px-4 rounded-xl text-lg">Play Again</button>
                    <button id="share-score-btn" class="flex-1 themed-button text-white font-bold py-3 px-4 rounded-xl text-lg flex items-center justify-center gap-2" style="background: var(--accent-gradient-shaded);">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z" />
                        </svg>
                        <span>Share</span>
                    </button>
                </div>
                <button id="change-edition-btn-modal" class="no-screenshot themed-button w-full py-2.5 px-4 text-sm font-semibold rounded-lg mt-2" style="color: var(--accent); background-color: var(--accent-light);">
                    Choose a different Game Edition
                </button>
            </div>
        </div>
    </div>

    <div id="exchange-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm text-center themed-modal p-6 transform scale-95 -translate-y-4">
            <h2 id="exchange-modal-title" class="text-xl font-bold mb-4" style="color: var(--accent);">Choose a new Alloha</h2>
            <div id="exchange-options" class="grid grid-cols-3 gap-4"></div>
        </div>
    </div>

    <div id="tutorial-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-md text-center themed-modal p-8 transform scale-95 -translate-y-4 relative">
            <button id="close-tutorial-btn" aria-label="Close Tutorial" class="absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-4xl font-bold mb-2" style="font-family: 'Pacifico', cursive; color: var(--accent);">Welcome to Alloha!</h2>
            <div id="tutorial-content" class="text-lg mt-4 mb-6" style="color: var(--text-secondary);">
                </div>
            <div class="tutorial-progress flex justify-center mt-4 gap-2">
                <div class="tutorial-progress-dot active"></div>
                <div class="tutorial-progress-dot"></div>
                <div class="tutorial-progress-dot"></div>
                <div class="tutorial-progress-dot"></div>
            </div>
            <button id="tutorial-next-btn" class="themed-button text-white font-bold py-3 px-6 rounded-xl text-lg mt-6" style="background: var(--accent-gradient);">Next</button>
        </div>
    </div>

    <div id="warning-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm themed-modal p-8 text-center transform scale-95 -translate-y-4 relative">
            <button id="close-warning-x-btn" aria-label="Close Warning" class="absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-2xl font-bold mb-4" style="color: var(--accent);">Action Needed!</h2>
            <p class="mb-6" style="color: var(--text-secondary);">Please place your current Allohas on the board before rolling the dice again.</p>
            <div class="flex justify-center items-center">
                <button id="close-warning-btn" class="py-2 px-8 themed-button text-white text-sm">OK</button>
            </div>
        </div>
    </div>

    <div id="unlock-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm themed-modal p-8 text-center transform scale-95 -translate-y-4 relative">
            <button id="close-unlock-x-btn" aria-label="Close Unlock Notification" class="absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-3xl font-bold mb-2" style="font-family: 'Pacifico', cursive; color: var(--accent);">Edition Unlocked!</h2>
            <p class="text-lg mt-4 mb-6" style="color: var(--text-secondary);">Congratulations, you can now play:</p>
            <p id="unlocked-edition-name" class="text-2xl font-bold mb-6" style="color: var(--text);"></p>
            <button id="close-unlock-btn" class="py-2 px-8 themed-button text-white text-sm">Awesome!</button>
        </div>
    </div>
    
    <div id="badges-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-md text-center themed-modal p-6 transform scale-95 -translate-y-4">
            <button id="close-badges-btn" aria-label="Close Badges" class="no-screenshot absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-4xl font-bold mb-1" style="font-family: 'Pacifico', cursive; color: var(--accent);">Collect Alloha Badges</h2>
            <p id="badge-info-text" class="text-sm min-h-10 flex items-center justify-center" style="color: var(--text-secondary);">Click a badge to see how to unlock it.</p>
            <div id="badges-grid" class="grid grid-cols-3 gap-x-4 gap-y-2 lg:gap-x-6 lg:gap-y-4">
                </div>
            <button id="share-badges-btn" class="no-screenshot themed-button w-full py-2.5 px-4 text-sm font-semibold rounded-lg mt-6" style="background: var(--accent-gradient-shaded); color: white;">
                Share Badges
            </button>
        </div>
    </div>

    <div id="post-game-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm themed-modal p-8 text-center transform scale-95 -translate-y-4">
            <button id="close-post-game-modal-btn" aria-label="Close" class="absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-2xl font-bold mb-4" style="color: var(--accent);">Game Over!</h2>
            <p class="mb-6" style="color: var(--text-secondary);">What would you like to do next?</p>
            <div class="flex flex-col justify-center items-center gap-3">
                <button id="post-game-play-again-btn" class="w-full py-2.5 px-4 themed-button text-white text-sm" style="background: var(--accent-gradient);">Play This Edition Again</button>
                <button id="post-game-select-edition-btn" class="w-full py-2.5 px-4 themed-button text-sm" style="color: var(--accent); background: var(--accent-light);">Choose New Edition</button>
            </div>
        </div>
    </div>

    <script>
        
    (function() {
        const DEV_UNLOCK_ALL = false;

        const CONSTANTS = {
            TOAST_DURATION: 3000,
            SPARKLE_DURATION: 700,
            FLOATING_SCORE_DURATION: 1200,
            SHAKE_ANIMATION_DURATION: 400,
            DICE_TUMBLE_DURATION: 600,
            TWINNING_FLASH_DURATION: 1500,
            MOVE_COMPLETION_DELAY: 300,
            CURSE_EFFECT_DURATION: 700,
            GOLDEN_ALLOHA_DELAY: 500,
            END_GAME_MODAL_DELAY: 500,
            CONFETTI_DURATION: 4000,
            VARIANT_SWITCH_DELAY: 250,
        };

        const SUPERPOWERS = {
            PAST_LIVES: 'pastLives',
            BOMB_BAE: 'bombBae',
            NO_RETURN: 'noReturn',
            SWAP_THEM: 'swapThem',
        };
        
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        const badgeConfigs = {
            baby: { name: 'Baby', emoji: '👶', description: 'Complete your first game of Alloha.' },
            enthusiast: { name: 'Enthusiast', emoji: '🎮', description: 'Play 10 games in any mode.' },
            veteran: { name: 'Veteran', emoji: '🎖️', description: 'Play 50 games in any mode.' },
            onFire: { name: 'On Fire', emoji: '🔥', description: 'Win 3 days in a row.' },
            unstoppable: { name: 'Unstoppable', emoji: '🔥🔥', description: 'Win 7 days in a row.' },
            legendary: { name: 'Legendary', emoji: '🔥🔥🔥', description: 'Win 30 days in a row.' },
            timeTraveller: { name: 'Time Traveller', emoji: '⏱️', description: 'Complete your first game in Time Burst mode.' },
            masterOfTime: { name: 'Master of Time', emoji: '⏳', description: 'Win 10 games in Time Burst mode.' },
            centuryClub: { name: 'Century Club', emoji: '🏆', description: 'Score over 100 points in a single game.' },
            perfectionist: { name: 'Perfectionist', emoji: '🎯', description: 'Create a line of 7 identical Allohas.' },
            gridMaster: { name: 'Grid Master', emoji: '🎨', description: 'Finish a game with no empty blocks.' },
            pureSkill: { name: 'Pure Skill', emoji: '🎀', description: 'Win a game without using any superpowers.' },
            fineNine: { name: 'Fine Nine', emoji: '🖼️', description: 'Create a 3x3 Grid Bonus of the same Alloha.' },
            fineSquare: { name: 'Fine Square', emoji: '🏁', description: 'Create a 4x4 Grid Bonus of the same Alloha.' },
            heroWorship: { name: 'Hero Worship', emoji: '🦸', description: 'Score all 14 Hero Bonus points in a single game.' },
            explorer: { name: 'Explorer', emoji: '🗺️', description: 'Play a game in 5 different Game Editions.' },
            collector: { name: 'Collector', emoji: '👑', description: 'Play a game in every available Game Edition.' },
            allRounder: { name: 'All-Rounder', emoji: '⚖️', description: 'Win a game in both Classic and Time Burst modes.' },
        };

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'toast-notification';
            toast.innerHTML = message;
            toast.setAttribute('aria-live', 'assertive');
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), CONSTANTS.TOAST_DURATION);
        }

        function getPlayerStats() {
            try {
                const stats = localStorage.getItem('allohaPlayerStats');
                return stats ? JSON.parse(stats) : {
                    gamesPlayed: 0,
                    timeBurstGamesPlayed: 0,
                    timeBurstWins: 0,
                    classicWins: 0,
                    playedEditions: {},
                    unlockedEditions: {},
                    unlockedBadges: {}
                };
            } catch (e) {
                console.error("Could not access localStorage. Progress will not be saved.", e);
                return {
                    gamesPlayed: 0,
                    timeBurstGamesPlayed: 0,
                    timeBurstWins: 0,
                    classicWins: 0,
                    playedEditions: {},
                    unlockedEditions: {},
                    unlockedBadges: {}
                };
            }
        }

        function savePlayerStats(stats) {
            try {
                localStorage.setItem('allohaPlayerStats', JSON.stringify(stats));
                return true;
            } catch (e) {
                console.error("Could not save to localStorage.", e);
                
                // User-friendly error notification
                if (e.name === 'QuotaExceededError') {
                    showToast('⚠️ Storage full! Progress may not save. Clear browser data to continue.');
                } else if (e.message && e.message.includes('access')) {
                    showToast('⚠️ Cannot save progress. Check if cookies/storage is enabled.');
                } else {
                    showToast('⚠️ Could not save progress.');
                }
                return false;
            }
        }

        function unlockBadge(badgeId, statsObj = null) {
            let stats = statsObj || getPlayerStats();
            if (!stats.unlockedBadges[badgeId]) {
                const badge = badgeConfigs[badgeId];
                stats.unlockedBadges[badgeId] = { unlockedAt: new Date().toISOString() };
                if (!statsObj) { // Only save if we had to fetch the stats ourselves
                    const saved = savePlayerStats(stats);
                    if (!saved) {
                        console.warn(`Failed to save badge unlock for ${badgeId}`);
                        // User already notified by savePlayerStats via showToast
                    }
                }
                showToast(`<span>${badge.emoji}</span> Badge Unlocked: ${badge.name}`);
            }
        }

        function renderBadgesGrid(elements) {
            const grid = elements.badges_grid;
            const infoText = elements.badge_info_text;
            if (!grid || !infoText) return;

            grid.innerHTML = '';
            infoText.textContent = 'Click a badge to see how to unlock it.';

            const stats = getPlayerStats();

            for (const badgeId in badgeConfigs) {
                const badge = badgeConfigs[badgeId];
                const isUnlocked = !!stats.unlockedBadges[badgeId];

                const item = document.createElement('div');
                item.className = 'badge-item';
                if (!isUnlocked) {
                    item.classList.add('locked');
                }

                item.innerHTML = `
                    <div class="badge-emoji">${badge.emoji}</div>
                    <div class="badge-name">${badge.name}</div>
                `;

                item.addEventListener('click', () => {
                    infoText.textContent = `${badge.name}: ${badge.description}`;
                });

                grid.appendChild(item);
            }
        }

        function createSparkles(element) {
            const rect = element.getBoundingClientRect();
            const container = document.body;
            for (let i = 0; i < 8; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                sparkle.style.top = `${rect.top + rect.height / 2}px`;
                sparkle.style.left = `${rect.left + rect.width / 2}px`;
                const randomAngle = Math.random() * 2 * Math.PI;
                const randomDist = Math.random() * 50 + 20;
                sparkle.style.setProperty('--sparkle-x', `${Math.cos(randomAngle) * randomDist}px`);
                sparkle.style.setProperty('--sparkle-y', `${Math.sin(randomAngle) * randomDist}px`);
                container.appendChild(sparkle);
                setTimeout(() => sparkle.remove(), CONSTANTS.SPARKLE_DURATION);
            }
        }

        function showFloatingScore(text, sourceElement) {
            const floater = document.createElement('div');
            floater.className = 'floating-score';
            floater.textContent = text;
            const startRect = sourceElement.getBoundingClientRect();
            floater.style.top = `${startRect.top + startRect.height / 2 - 15}px`;
            floater.style.left = `${startRect.left + startRect.width / 2 - 15}px`;
            document.body.appendChild(floater);
            setTimeout(() => floater.remove(), CONSTANTS.FLOATING_SCORE_DURATION);
        }

        function animateScoreUpdate(containerId, newValue, minLength = 1) {
            const container = document.getElementById(containerId);
            if (!container) return;

            const oldValue = parseInt(container.textContent || '0');
            if (newValue > oldValue) {
                if(container.getBoundingClientRect().width > 0) createSparkles(container);
            }

            let valueStr;
            if (newValue < 0) {
                valueStr = `(${String(Math.abs(newValue)).padStart(minLength, '0')})`;
            } else {
                valueStr = String(newValue).padStart(minLength, '0');
            }
            container.textContent = valueStr;
        }
        
        async function handleShareBadges(shareBtn, modalContent) {
            if (!shareBtn || !modalContent) return;
    
            const originalBtnText = shareBtn.textContent;
    
            try {
                shareBtn.textContent = 'Generating...';
                shareBtn.disabled = true;
    
                await new Promise(resolve => setTimeout(resolve, 50));
    
                const canvas = await html2canvas(modalContent, {
                    allowTaint: true,
                    useCORS: true,
                    backgroundColor: null,
                    ignoreElements: (element) => element.classList.contains('no-screenshot')
                });
    
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                if (!blob) throw new Error("Canvas to Blob conversion failed.");
                
                const file = new File([blob], 'alloha-badges.png', { type: 'image/png' });
                const shareText = `🏆 Check out my Badge Collection in Alloha! 🏆\n\nPlay now: https://abhimanyulodha.github.io/alloha/`;
    
                if (navigator.share && navigator.canShare({ files: [file] })) {
                    await navigator.share({
                        title: 'My Alloha Badges!',
                        text: shareText,
                        files: [file]
                    });
                } else {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = 'Alloha-Badges.png';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(link.href);
                }
            } catch (error) {
                console.error('Badge sharing failed:', error);
                shareBtn.textContent = 'Error!';
            } finally {
                setTimeout(() => {
                    shareBtn.textContent = originalBtnText;
                    shareBtn.disabled = false;
                }, 2000);
            }
        }

        const themeConfigs = {
            pastel_pals: { name: "Pastel Pals", symbols: ['🐰', '🐶', '🐯', '🐼', '🦄', '🐸'], palette: { bg: 'linear-gradient(135deg, #F3E5F5 0%, #E1BEE7 100%)', card: 'rgba(255, 255, 255, 0.88)', text: '#4A148C', text_secondary: '#7B1FA2', accent: '#8E24AA', 'accent-light': '#F3E5F5', accent_gradient: 'linear-gradient(135deg, #8E24AA 0%, #AB47BC 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #BA68C8 0%, #CE93D8 100%)', highlighted_bg: 'rgba(142, 36, 170, 0.15)', highlighted_border: 'rgba(142, 36, 170, 0.3)', grid_cell_bg: '#F9F6FB', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🐰':'text-pink-400', '🐶':'text-amber-600', '🐯':'text-orange-500', '🐼':'text-gray-700', '🦄':'text-purple-500', '🐸':'text-green-500' } },
            green_grocer: { name: "Green Grocer", symbols: ['🥑', '🥦', '🧄', '🌽', '🫑', '🌶️'], palette: { bg: 'linear-gradient(135deg, #F1F8E9 0%, #DCEDC8 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#33691E', text_secondary: '#689F38', accent: '#8BC34A', 'accent-light': '#F1F8E9', accent_gradient: 'linear-gradient(135deg, #8BC34A 0%, #9CCC65 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #AED581 0%, #C5E1A5 100%)', highlighted_bg: 'rgba(139, 195, 74, 0.15)', highlighted_border: 'rgba(139, 195, 74, 0.3)', grid_cell_bg: '#FCFFF5', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🥑':'text-green-800', '🥦':'text-green-600', '🧄':'text-gray-500', '🌽':'text-yellow-500', '🫑':'text-green-700', '🌶️':'text-red-600' } },
            bug_life: { name: "Bug's Life", symbols: ['🦋', '🐝', '🪲', '🐛', '🐞', '🪰'], palette: { bg: 'linear-gradient(135deg, #E0F2F1 0%, #B2DFDB 100%)', card: 'rgba(255, 255, 255, 0.85)', text: '#004D40', text_secondary: '#00796B', accent: '#009688', 'accent-light': '#E0F2F1', accent_gradient: 'linear-gradient(135deg, #009688 0%, #26A69A 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #4DB6AC 0%, #80CBC4 100%)', highlighted_bg: 'rgba(0, 150, 136, 0.15)', highlighted_border: 'rgba(0, 150, 136, 0.3)', grid_cell_bg: '#F5FCFB', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🦋':'text-blue-500', '🐝':'text-yellow-500', '🪲':'text-amber-800', '🐛':'text-lime-600', '🐞':'text-red-600', '🪰':'text-gray-700' } },
            hats_off: { name: "Hats Off", symbols: ['🪖', '🎩', '🧢', '👒', '⛑️', '👑'], palette: { bg: 'linear-gradient(135deg, #A1887F 0%, #795548 100%)', card: 'rgba(255, 255, 255, 0.85)', text: '#3E2723', text_secondary: '#5D4037', accent: '#FFD700', 'accent-light': '#6D4C41', accent_gradient: 'linear-gradient(135deg, #FFD700 0%, #FFC107 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #5D4037 0%, #4E342E 100%)', highlighted_bg: 'rgba(255, 215, 0, 0.45)', highlighted_border: 'rgba(255, 215, 0, 0.6)', grid_cell_bg: '#EFEBE9', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🪖':'text-green-800', '🎩':'text-gray-800', '🧢':'text-blue-600', '👒':'text-pink-400', '⛑️':'text-red-600', '👑':'text-yellow-500' } },
            golden_bakery: { name: "Golden Bakery", symbols: ['🍞', '🥯', '🥐', '🧇', '🍪', '🥞'], palette: { bg: 'linear-gradient(135deg, #FFF8E1 0%, #FFECB3 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#8D6E63', text_secondary: '#A1887F', accent: '#AF8260', 'accent-light': '#FFF8E1', accent_gradient: 'linear-gradient(135deg, #AF8260 0%, #C19A7B 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #D4B298 0%, #E6C9B4 100%)', highlighted_bg: 'rgba(175, 130, 96, 0.15)', highlighted_border: 'rgba(175, 130, 96, 0.3)', grid_cell_bg: '#FFFBF2', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🍞':'text-amber-800', '🥯':'text-amber-700', '🥐':'text-orange-600', '🧇':'text-yellow-700', '🍪':'text-amber-900', '🥞':'text-amber-600' } },
            sporty_vibes: { name: "Sporty Vibes", symbols: ['🏀', '⚽️', '🥎', '🏉', '🏐', '🏈'], palette: { bg: 'linear-gradient(135deg, #4CAF50 0%, #388E3C 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#1B5E20', text_secondary: '#2E7D32', accent: '#FF9800', 'accent-light': '#C8E6C9', accent_gradient: 'linear-gradient(135deg, #FF9800 0%, #FFA726 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFB74D 0%, #FFCC80 100%)', highlighted_bg: 'rgba(255, 152, 0, 0.45)', highlighted_border: 'rgba(255, 152, 0, 0.6)', grid_cell_bg: '#F1F8E9', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🏀':'text-orange-600', '⚽️':'text-black', '🥎':'text-lime-400', '🏉':'text-amber-800', '🏐':'text-blue-500', '🏈':'text-amber-900' } },
            school_of_magic: { name: "School of Magic", symbols: ['🧙‍♀️', '🦉', '📜', '🏆', '🏟️', '🔮'], palette: { bg: 'linear-gradient(135deg, #F5F5DC 0%, #FFF8E7 100%)', card: 'rgba(255, 250, 240, 0.9)', text: '#5D4037', text_secondary: '#A1887F', accent: '#880808', 'accent-light': 'rgba(136, 8, 8, 0.1)', accent_gradient: 'linear-gradient(135deg, #880808 0%, #C58940 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #A43535 0%, #E0A75E 100%)', highlighted_bg: 'rgba(218, 165, 32, 0.15)', highlighted_border: 'rgba(218, 165, 32, 0.3)', grid_cell_bg: '#FFFDF5', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🧙‍♀️':'text-purple-600', '🦉':'text-gray-500', '📜':'text-amber-800', '🏆':'text-yellow-500', '🏟️':'text-gray-600', '🔮':'text-indigo-500' } },
            emoji_fun: { name: "Emoji Fun", symbols: ['😍', '😎', '🤩', '😂', '🥵', '🤯'], palette: { bg: 'linear-gradient(135deg, #FFF9C4 0%, #FFF176 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#4E342E', text_secondary: '#795548', accent: '#42A5F5', 'accent-light': '#E3F2FD', accent_gradient: 'linear-gradient(135deg, #42A5F5 0%, #64B5F6 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #90CAF9 0%, #BBDEFB 100%)', highlighted_bg: 'rgba(66, 165, 245, 0.15)', highlighted_border: 'rgba(66, 165, 245, 0.3)', grid_cell_bg: '#FFFDE7', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '😍':'text-red-500', '😎':'text-black', '🤩':'text-yellow-600', '😂':'text-blue-500', '🥵':'text-orange-500', '🤯':'text-purple-500' } },
            deep_ocean: { name: "Deep Ocean", symbols: ['🐡', '🦑', '🦀', '🐙', '🐳', '🐠'], palette: { bg: 'linear-gradient(135deg, #E0F7FA 0%, #B2EBF2 100%)', card: 'rgba(240, 255, 255, 0.9)', text: '#004D40', text_secondary: '#00796B', accent: '#FF7F50', 'accent-light': 'rgba(255, 127, 80, 0.1)', accent_gradient: 'linear-gradient(135deg, #FF7F50 0%, #FFB74D 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFA07A 0%, #FFD54F 100%)', highlighted_bg: 'rgba(255, 127, 80, 0.15)', highlighted_border: 'rgba(255, 127, 80, 0.3)', grid_cell_bg: '#F0FFFF', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🐡':'text-yellow-600', '🦑':'text-pink-500', '🦀':'text-red-600', '🐙':'text-purple-500', '🐳':'text-blue-600', '🐠':'text-orange-500' } },
            road_block_theme: { name: "Road Block", symbols: ['🚑', '🚌', '🚗', '🚎', '🚜', '✈️'], palette: { bg: 'linear-gradient(135deg, #B0BEC5 0%, #78909C 100%)', card: 'rgba(255, 255, 255, 0.8)', text: '#263238', text_secondary: '#455A64', accent: '#FFC107', 'accent-light': '#CFD8DC', accent_gradient: 'linear-gradient(135deg, #FFCA28 0%, #FFD54F 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFE082 0%, #FFEE58 100%)', highlighted_bg: 'rgba(255, 193, 7, 0.15)', highlighted_border: 'rgba(255, 193, 7, 0.3)', grid_cell_bg: '#ECEFF1', toggle_bg_inactive: 'rgba(0,0,0,0.2)', }, symbolColors: { '🚑':'text-red-500', '🚌':'text-yellow-500', '🚗':'text-blue-500', '🚎':'text-green-500', '🚜':'text-orange-500', '✈️':'text-gray-400' } },
            the_post_office: { name: "The Post Office", symbols: ['📦', '📮', '🗂️', '🗳️', '🗄️', '📬'], palette: { bg: 'linear-gradient(135deg, #EFEBE9 0%, #D7CCC8 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#3E2723', text_secondary: '#6D4C41', accent: '#D32F2F', 'accent-light': '#FFCDD2', accent_gradient: 'linear-gradient(135deg, #D32F2F 0%, #E53935 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #EF5350 0%, #E57373 100%)', highlighted_bg: 'rgba(211, 47, 47, 0.1)', highlighted_border: 'rgba(211, 47, 47, 0.25)', grid_cell_bg: '#F8F5F3', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '📦':'text-amber-800', '📮':'text-red-600', '🗂️':'text-gray-500', '🗳️':'text-blue-700', '🗄️':'text-gray-600', '📬':'text-red-700' } },
            tutti_frutti: { name: "Tutti Frutti", symbols: ['🍓', '🫐', '🍉', '🥝', '🥭', '🍋'], palette: { bg: 'linear-gradient(135deg, #FFFFFF 0%, #F5F5F5 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#4E342E', text_secondary: '#6D4C41', accent: '#EC407A', 'accent-light': '#FCE4EC', accent_gradient: 'linear-gradient(135deg, #EC407A 0%, #F06292 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #F48FB1 0%, #F8BBD0 100%)', highlighted_bg: 'rgba(236, 64, 122, 0.1)', highlighted_border: 'rgba(236, 64, 122, 0.25)', grid_cell_bg: '#FFFFFF', toggle_bg_inactive: '#F0F0F0', }, symbolColors: { '🍓':'text-red-500', '🫐':'text-blue-600', '🍉':'text-green-600', '🥝':'text-lime-700', '🥭':'text-orange-500', '🍋':'text-yellow-500' } },
            zedi_zodi: { name: "Zodiac Night", symbols: ['♋', '♒', '♎', '♐', '♌', '♉'], palette: { bg: 'linear-gradient(135deg, #0f0c29 0%, #302b63 100%)', card: 'rgba(48, 43, 99, 0.75)', text: '#FFFFFF', text_secondary: '#A9B4D1', accent: '#FFD700', 'accent-light': '#4A428A', accent_gradient: 'linear-gradient(135deg, #FFD700 0%, #FFA000 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFECB3 0%, #FFD54F 100%)', highlighted_bg: 'rgba(255, 215, 0, 0.15)', highlighted_border: 'rgba(255, 215, 0, 0.3)', grid_cell_bg: '#6A6E89', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '♋':'text-gray-300', '♒':'text-blue-300', '♎':'text-pink-300', '♐':'text-orange-300', '♌':'text-yellow-300', '♉':'text-green-300' } },
            desert_oasis: { name: "Desert Oasis", symbols: ['🌵', '🪨', '☀️', '🐍', '⛺', '🌴'], palette: { bg: 'linear-gradient(135deg, #FFECB3 0%, #FFD54F 100%)', card: 'rgba(255, 255, 255, 0.85)', text: '#5D4037', text_secondary: '#6D4C41', accent: '#00897B', 'accent-light': '#B2DFDB', accent_gradient: 'linear-gradient(135deg, #00897B 0%, #26A69A 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #4DB6AC 0%, #80CBC4 100%)', highlighted_bg: 'rgba(0, 137, 123, 0.15)', highlighted_border: 'rgba(0, 137, 123, 0.3)', grid_cell_bg: '#FFFBF2', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🌵':'text-green-700', '🪨':'text-gray-600', '☀️':'text-yellow-600', '🐍':'text-emerald-800', '⛺':'text-orange-700', '🌴':'text-lime-800' } },
            morning_aviary: { name: "Morning Aviary", symbols: ['🐔', '🐦', '🐥', '🐣', '🐝', '🐧'], palette: { bg: 'linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#0D47A1', text_secondary: '#1976D2', accent: '#FFA000', 'accent-light': '#FFECB3', accent_gradient: 'linear-gradient(135deg, #FFA000 0%, #FFB300 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFC107 0%, #FF8F00 100%)', highlighted_bg: 'rgba(255, 160, 0, 0.15)', highlighted_border: 'rgba(255, 160, 0, 0.3)', grid_cell_bg: '#F7FBFF', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🐔':'text-red-600', '🐦':'text-blue-500', '🐥':'text-yellow-500', '🐣':'text-yellow-400', '🐝':'text-yellow-600', '🐧':'text-gray-800' } },
            creepy_crawlies: { name: "Sandstone Valley", symbols: ['🐍', '🦎', '🦂', '🐭', '🥚', '🐁'], palette: { bg: 'linear-gradient(135deg, #EFEBE9 0%, #D7CCC8 100%)', card: 'rgba(255, 255, 255, 0.92)', text: '#3E2723', text_secondary: '#5D4037', accent: '#BF360C', 'accent-light': 'rgba(191, 54, 12, 0.08)', accent_gradient: 'linear-gradient(135deg, #BF360C 0%, #D84315 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FF5722 0%, #FF7043 100%)', highlighted_bg: 'rgba(191, 54, 12, 0.1)', highlighted_border: 'rgba(191, 54, 12, 0.3)', grid_cell_bg: '#FAF8F6', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🐍':'text-green-900', '🦎':'text-lime-800', '🦂':'text-red-900', '🐭':'text-gray-800', '🥚':'text-stone-600', '🐁':'text-slate-800' } },
            ancient_secrets: { name: "Ancient Secrets", symbols: ['🔍', '🧩', '🀄', '🔑', '🧭', '👁️'], palette: { bg: 'linear-gradient(135deg, #5D4037 0%, #3E2723 100%)', card: 'rgba(62, 39, 35, 0.75)', text: '#D7CCC8', text_secondary: '#D7CCC8', accent: '#FFCA28', 'accent-light': '#4E342E', accent_gradient: 'linear-gradient(135deg, #FFC107 0%, #FF8F00 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFA000 0%, #FF6F00 100%)', highlighted_bg: 'rgba(255, 202, 40, 0.15)', highlighted_border: 'rgba(255, 202, 40, 0.3)', grid_cell_bg: '#795548', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '🔍':'text-blue-300', '🧩':'text-orange-300', '🀄':'text-red-300', '🔑':'text-yellow-300', '🧭':'text-gray-300', '👁️':'text-cyan-300' } },
            cosmic_drift: { name: "Cosmic Drift", symbols: ['🌍', '🚀', '🪐', '🌗', '💫', '🛰️'], palette: { bg: 'linear-gradient(135deg, #1A237E 0%, #0D123B 100%)', card: 'rgba(48, 59, 128, 0.7)', text: '#E8EAF6', text_secondary: '#9FA8DA', accent: '#536DFE', 'accent-light': '#1A237E', accent_gradient: 'linear-gradient(135deg, #536DFE 0%, #7C4DFF 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #7C4DFF 0%, #B388FF 100%)', highlighted_bg: 'rgba(83, 109, 254, 0.2)', highlighted_border: 'rgba(83, 109, 254, 0.4)', grid_cell_bg: '#5C6BC0', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '🌍':'text-blue-300', '🚀':'text-gray-200', '🪐':'text-amber-300', '🌗':'text-gray-100', '💫':'text-yellow-300', '🛰️':'text-blue-200' } },
            petal_meadow: { name: "Petal Meadow", symbols: ['🌸', '🌺', '🌷', '🪷', '🪻', '🌻'], palette: { bg: 'linear-gradient(135deg, #E6EE9C 0%, #C5E1A5 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#2E7D32', text_secondary: '#558B2F', accent: '#D81B60', 'accent-light': '#F8BBD0', accent_gradient: 'linear-gradient(135deg, #D81B60 0%, #E91E63 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #F06292 0%, #F48FB1 100%)', highlighted_bg: 'rgba(216, 27, 96, 0.1)', highlighted_border: 'rgba(216, 27, 96, 0.25)', grid_cell_bg: '#F8FFF0', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🌸':'text-pink-400', '🌺':'text-red-500', '🌷':'text-orange-500', '🪷':'text-pink-500', '🪻':'text-purple-500', '🌻':'text-yellow-500' } },
            monster_mash: { name: "Monster Mash", symbols: ['👹', '🐲', '👻', '👽', '🎃', '😈'], palette: { bg: 'linear-gradient(135deg, #432874 0%, #18142a 100%)', card: 'rgba(40, 30, 60, 0.8)', text: '#E0D6FF', text_secondary: '#BCA9F0', accent: '#FF7900', 'accent-light': '#6A1B9A', accent_gradient: 'linear-gradient(135deg, #FF7900 0%, #FF983D 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFB47A 0%, #FFD0B1 100%)', highlighted_bg: 'rgba(255, 121, 0, 0.15)', highlighted_border: 'rgba(255, 121, 0, 0.3)', grid_cell_bg: '#4A3F71', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '👹':'text-red-400', '🐲':'text-green-400', '👻':'text-gray-200', '👽':'text-lime-300', '🎃':'text-orange-400', '😈':'text-purple-400' } }
        };

        const unlockProgression = {
          // Each key is the ID of the game that must be PLAYED,
          // and its value is the game it UNLOCKS and the SCORE required.
          'plain_jean':      { unlocks: 'one_won',           score: 50 },
          'one_won':         { unlocks: 'plus_minus',        score: 50 },
          'plus_minus':      { unlocks: 'hat_trick',         score: 55 },
          'hat_trick':       { unlocks: 'sugar_cube',        score: 55 },
          'sugar_cube':      { unlocks: 'spoil_sport',       score: 60 },
          'spoil_sport':     { unlocks: 'marry_harry',       score: 60 },
          'marry_harry':     { unlocks: 'cosy_emoji',        score: 65 },
          'cosy_emoji':      { unlocks: 'wonder_wander',     score: 65 },
          'wonder_wander':   { unlocks: 'road_block',        score: 70 },
          'road_block':      { unlocks: 'box_vox',           score: 70 },
          'box_vox':         { unlocks: 'hash_hush',         score: 75 },
          'hash_hush':       { unlocks: 'zedi_zodi',         score: 75 },
          'zedi_zodi':       { unlocks: 'core',              score: 80 }, // 'core' is Cacti Facti
          'core':            { unlocks: 'eight_and_watch',   score: 80 },
          'eight_and_watch': { unlocks: 'fake_snake',        score: 85 },
          'fake_snake':      { unlocks: 'rune_dune',         score: 85 },
          'rune_dune':       { unlocks: 'space_race',        score: 90 },
          'space_race':      { unlocks: 'flower_power',      score: 90 },
          'flower_power':    { unlocks: 'monster',           score: 95 },
          'monster':         null // The last game, unlocks nothing
        };

        function generateCrossScoreSegments(isTwinningCell) {
            const segments = [];
            const GRID_SIZE = 7;
            const MIN_SEQUENCE_LENGTH = 3;

            // Helper to find contiguous segments in an array of indices
            function findContiguousSegments(indices) {
                if (indices.length === 0) return [];
                indices.sort((a, b) => a - b);
                const result = [];
                let currentSegment = [indices[0]];
                for (let i = 1; i < indices.length; i++) {
                    if (indices[i] === indices[i - 1] + 1) {
                        currentSegment.push(indices[i]);
                    } else {
                        result.push(currentSegment);
                        currentSegment = [indices[i]];
                    }
                }
                result.push(currentSegment);
                return result;
            }

            // Check rows
            for (let r = 0; r < GRID_SIZE; r++) {
                const highlightedCols = [];
                for (let c = 0; c < GRID_SIZE; c++) {
                    if (isTwinningCell(r, c)) {
                        highlightedCols.push(c);
                    }
                }
                const colSegments = findContiguousSegments(highlightedCols);
                colSegments.forEach(seg => {
                    if (seg.length >= MIN_SEQUENCE_LENGTH) {
                        segments.push({ type: 'row', index: r, start: seg[0], end: seg[seg.length - 1] });
                    }
                });
            }

            // Check columns
            for (let c = 0; c < GRID_SIZE; c++) {
                const highlightedRows = [];
                for (let r = 0; r < GRID_SIZE; r++) {
                    if (isTwinningCell(r, c)) {
                        highlightedRows.push(r);
                    }
                }
                const rowSegments = findContiguousSegments(highlightedRows);
                rowSegments.forEach(seg => {
                    if (seg.length >= MIN_SEQUENCE_LENGTH) {
                        segments.push({ type: 'col', index: c, start: seg[0], end: seg[seg.length - 1] });
                    }
                });
            }
            return segments;
        }

        const variantConfigs = {
            'plain_jean': { id: 'plain_jean', name: 'Plain Jean', themeId: 'pastel_pals', timeLimit: 100, isTwinningCell: (r, c) => false, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'one_won': { id: 'one_won', name: 'One Won', themeId: 'green_grocer', timeLimit: 100, isTwinningCell: (r, c) => c === 3, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'plus_minus': { id: 'plus_minus', name: 'Plus Minus', themeId: 'bug_life', timeLimit: 100, isTwinningCell: (r, c) => r === 3 || c === 3, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'hat_trick': { id: 'hat_trick', name: 'Hat Trick', themeId: 'hats_off', timeLimit: 100, isTwinningCell: (r, c) => r === 0 || r === 6 || c === 0, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'sugar_cube': { id: 'sugar_cube', name: 'Sugar Cube', themeId: 'golden_bakery', timeLimit: 100, isTwinningCell: (r, c) => r === 0 || r === 6 || c === 0 || c === 6, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'spoil_sport': { id: 'spoil_sport', name: 'Spoil Sport', themeId: 'sporty_vibes', timeLimit: 100, isTwinningCell: (r, c) => r === 0 || r === 3 || c === 0 || c === 6, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'marry_harry': { id: 'marry_harry', name: 'Marry Harry', themeId: 'school_of_magic', timeLimit: 100, isTwinningCell: (r, c) => c === 1 || c === 5 || (r === 3 && c >= 1 && c <= 5), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'cosy_emoji': { id: 'cosy_emoji', name: 'Cosy Emoji', themeId: 'emoji_fun', timeLimit: 100, isTwinningCell: (r, c) => r === 0 || r === 3 || r === 6 || c === 0, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'wonder_wander': { id: 'wonder_wander', name: 'Wonder Wander', themeId: 'deep_ocean', timeLimit: 120, isTwinningCell: (r, c) => r === 6 || [0, 3, 6].includes(c), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'road_block': { id: 'road_block', name: 'Road Block', themeId: 'road_block_theme', timeLimit: 120, isTwinningCell: (r, c) => [0, 2, 4, 6].includes(c), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'box_vox': { id: 'box_vox', name: 'Box Vox', themeId: 'the_post_office', timeLimit: 120, isTwinningCell: (r, c) => [0, 3, 6].includes(r) || [0, 3, 6].includes(c), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'hash_hush': { id: 'hash_hush', name: 'Hash Hush', themeId: 'tutti_frutti', timeLimit: 120, isTwinningCell: (r, c) => [2, 4].includes(r) || [2, 4].includes(c), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'zedi_zodi': { id: 'zedi_zodi', name: 'Zedi Zodi', themeId: 'zedi_zodi', timeLimit: 120, isTwinningCell: (r, c) => r === 0 || r === 6 || r + c === 6, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); }, hasSpecialDiagonal: true, getSpecialDiagonalCells: function() { const cells = []; for (let i = 0; i < 7; i++) { cells.push({ r: i, c: 6 - i }); } return cells; } },
            'core': { id: 'core', name: 'Cacti Facti Edition', themeId: 'desert_oasis', timeLimit: 150, isTwinningCell: (r, c) => (r === 3 && c >= 3 && c <= 5) || (r === 5 && c >= 1 && c <= 3) || (c === 1 && r >= 1 && r <= 5) || (c === 3) || (c === 5 && r >= 0 && r <= 3), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'eight_and_watch': { id: 'eight_and_watch', name: 'Eight and Watch', themeId: 'morning_aviary', timeLimit: 150, isTwinningCell: (r, c) => (r === 0 && c >= 3) || (r === 3) || (r === 6 && c <= 3) || (c === 0 && r >= 3) || (c === 3) || (c === 6 && r <= 3), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'fake_snake': { id: 'fake_snake', name: 'Fake Snake', themeId: 'creepy_crawlies', timeLimit: 150, isTwinningCell: (r, c) => (r === 0 && c >= 4) || (r === 2 && c >= 2 && c <= 4) || (r === 4 && c <= 2) || (c === 0 && r >= 4) || (c === 2 && r >= 2 && r <= 4) || (c === 4 && r <= 2), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'rune_dune': { id: 'rune_dune', name: 'Rune Dune', themeId: 'ancient_secrets', timeLimit: 150, isTwinningCell: (r, c) => (r === 2 && c >= 1 && c <= 5) || (r === 4 && c >= 1 && c <= 5) || (c === 1 && (r <= 2 || r >= 4)) || (c === 3) || (c === 5 && (r <= 2 || r >= 4)), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'space_race': { id: 'space_race', name: 'Space Race', themeId: 'cosmic_drift', timeLimit: 180, isTwinningCell: (r, c) => (r === 2 && c >= 2 && c <= 4) || (r === 3 && (c <= 2 || c >= 4)) || (r === 4 && c >= 2 && c <= 4) || (c === 2 && r >= 2 && r <= 4) || (c === 3 && (r <= 2 || r >= 4)) || (c === 4 && r >= 2 && r <= 4), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'flower_power': { id: 'flower_power', name: 'Flower Power', themeId: 'petal_meadow', timeLimit: 180, isTwinningCell: (r, c) => (r === 0 && c >= 2 && c <= 4) || (r === 2 && c >= 2 && c <= 4) || r === 4 || (c === 1 && r >= 3 && r <= 5) || (c === 2 && r <= 2) || (c === 3 && r >= 2) || (c === 4 && r <= 2) || (c === 5 && r >= 3 && r <= 5), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'monster': { id: 'monster', name: 'Monster Monster', themeId: 'monster_mash', timeLimit: 180, isTwinningCell: (r, c) => (r === 0 && c <= 2) || (r === 2 && c <= 4) || (r === 3 && c >= 4) || (r === 4 && c >= 2 && c <= 4) || (r === 6 && c <= 3) || (c === 0 && r <= 2) || (c === 2 && r <= 4) || (c === 3 && r >= 4) || (c === 4 && r >= 2 && r <= 4), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } }
        };

        function applyTheme(themeId) {
            const root = document.documentElement;
            const theme = themeConfigs[themeId] || themeConfigs.pastel_pals;
            Object.keys(theme.palette).forEach(key => {
                const cssVar = `--${key.replace(/_/g, '-')}`;
                root.style.setProperty(cssVar, theme.palette[key]);
            });
        }
        
        // --- Focus Trap for Modals ---
        let modalFocusTrapListener = null;
        let previouslyFocusedElement = null;

        function handleModalOpen(modalEl) {
            if (!modalEl) return;
            previouslyFocusedElement = document.activeElement;
            modalEl.classList.add('is-open');
            document.body.classList.add('modal-open');

            const focusableElements = modalEl.querySelectorAll(
                'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
            );
            const firstFocusable = focusableElements[0];
            const lastFocusable = focusableElements[focusableElements.length - 1];

            if (firstFocusable) {
                firstFocusable.focus();
            }

            modalFocusTrapListener = (e) => {
                if (e.key !== 'Tab') return;
                
                if (e.shiftKey) { // Shift + Tab
                    if (document.activeElement === firstFocusable) {
                        lastFocusable.focus();
                        e.preventDefault();
                    }
                } else { // Tab
                    if (document.activeElement === lastFocusable) {
                        firstFocusable.focus();
                        e.preventDefault();
                    }
                }
            };
            modalEl.addEventListener('keydown', modalFocusTrapListener);
        }

        function handleModalClose(modalEl) {
            if (!modalEl) return;
            modalEl.classList.remove('is-open');
            document.body.classList.remove('modal-open');
            
            if (modalFocusTrapListener) {
                modalEl.removeEventListener('keydown', modalFocusTrapListener);
                modalFocusTrapListener = null;
            }
            if (previouslyFocusedElement) {
                previouslyFocusedElement.focus();
                previouslyFocusedElement = null;
            }
        }


        class GameState {
            constructor() {
                this.states = {
                    PRE_GAME: 'PRE_GAME',
                    AWAITING_ROLL: 'AWAITING_ROLL',
                    ANIMATING_ROLL: 'ANIMATING_ROLL',
                    AWAITING_PLACEMENT: 'AWAITING_PLACEMENT',
                    SUPERPOWER_ACTIVE: 'SUPERPOWER_ACTIVE',
                    PROCESSING_TURN: 'PROCESSING_TURN',
                    AWAITING_GOLDEN_PLACEMENT: 'AWAITING_GOLDEN_PLACEMENT',
                    GAME_OVER: 'GAME_OVER'
                };
                this.currentState = this.states.PRE_GAME;
                this.validTransitions = {
                    [this.states.PRE_GAME]: [this.states.AWAITING_ROLL],
                    [this.states.AWAITING_ROLL]: [this.states.ANIMATING_ROLL, this.states.PRE_GAME, this.states.SUPERPOWER_ACTIVE, this.states.AWAITING_PLACEMENT, this.states.AWAITING_GOLDEN_PLACEMENT],
                    [this.states.ANIMATING_ROLL]: [this.states.AWAITING_PLACEMENT],
                    [this.states.AWAITING_PLACEMENT]: [this.states.PROCESSING_TURN, this.states.AWAITING_ROLL, this.states.SUPERPOWER_ACTIVE],
                    [this.states.SUPERPOWER_ACTIVE]: [this.states.AWAITING_ROLL, this.states.AWAITING_PLACEMENT, this.states.PROCESSING_TURN],
                    [this.states.PROCESSING_TURN]: [this.states.AWAITING_ROLL, this.states.GAME_OVER, this.states.AWAITING_GOLDEN_PLACEMENT],
                    [this.states.AWAITING_GOLDEN_PLACEMENT]: [this.states.GAME_OVER],
                    [this.states.GAME_OVER]: [this.states.PRE_GAME]
                };
            }
            setState(newState) { if (!this.validTransitions[this.currentState]?.includes(newState)) { console.warn(`Invalid state transition from ${this.currentState} to ${newState}`); return false; } this.currentState = newState; return true; }
            is(state) { return this.currentState === state; }
        }

        // --- HELPER CLASSES DEFINED FIRST ---
        class AudioManager {
            constructor() {
                this.unlocked = false;
                this.context = null;
                this.sounds = new Map();
            }

            init() {
                this._createContext();
                this._createSounds();
            }

            _createContext() {
                try {
                    if (!this.context) {
                        this.context = new (window.AudioContext || window.webkitAudioContext)();
                    }
                } catch (e) {
                    console.error("AudioContext not supported.", e);
                }
            }

            _createSounds() {
                if (!this.context || this.sounds.size > 0) return;
                const soundConfigs = {
                    'pop': [1200, 0.1, 0.05], 'roll': [220, 0.2, 0.2], 'hover': [660, 0.05, 0.1],
                    'invalid': [150, 0.3, 0.2], 'power-activate': [880, 0.15, 0.2],
                    'power-use': [1047, 0.2, 0.3], 'chime': [1047, 0.15, 0.2], 'thud': [100, 0.3, 0.1]
                };
                for (const key in soundConfigs) {
                    this.sounds.set(key, () => this._playTone(...soundConfigs[key]));
                }
            }

            _playTone(freq, vol, dur) {
                if (!this.unlocked || !this.context) return;
                try {
                    const o = this.context.createOscillator();
                    const g = this.context.createGain();
                    o.connect(g);
                    g.connect(this.context.destination);
                    o.frequency.value = freq;
                    g.gain.setValueAtTime(0, this.context.currentTime);
                    g.gain.linearRampToValueAtTime(vol * 0.1, this.context.currentTime + 0.01);
                    g.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + dur);
                    o.start();
                    o.stop(this.context.currentTime + dur);
                } catch (e) {
                    console.error("Error playing tone.", e);
                }
            }

            unlock(unlockerEl) {
                if (this.unlocked) return;
                unlockerEl.play()
                    .catch(err => {
                        // Ignore AbortError - it's expected for very short audio
                        if (err.name !== 'AbortError') {
                            console.error("Audio unlock failed:", err);
                        }
                    })
                    .finally(() => {
                        this.unlocked = true;
                    });
            }

            play(soundName) {
                const soundAction = this.sounds.get(soundName);
                if (soundAction) {
                    soundAction();
                }
            }
        }

        class Renderer {
            constructor(game, DOMElements) {
                this.game = game;
                this.DOMElements = DOMElements;
                this.gridCells = [];
            }
            
            async renderGrid() {
                const fragment = document.createDocumentFragment(); this.DOMElements.game_board.innerHTML = ''; this.gridCells = [];
                for (let r = 0; r < this.game.GRID_SIZE; r++) {
                    const row = [];
                    for (let c = 0; c < this.game.GRID_SIZE; c++) {
                        const cell = this.createCellElement(r, c); this.updateCell(cell, r, c); this.game.inputHandler.addCellEventListeners(cell);
                        fragment.appendChild(cell); row.push(cell);
                    }
                    this.gridCells.push(row);
                }
                this.DOMElements.game_board.appendChild(fragment);
            }

            createCellElement(r, c) { const cell = document.createElement('div'); cell.dataset.row = r; cell.dataset.col = c; cell.className = this.getCellClasses(r, c); return cell; }
            getCellClasses(r, c) {
                let classes = 'grid-cell';
                if (this.game.config.isTwinningCell(r, c)) classes += ' highlighted';
                if (this.game.stuckBlocks.has(`${r},${c}`)) classes += ' stuck-cell';
                if (this.game.heroBlocks.has(`${r},${c}`)) classes += ' hero-block-hint';
                return classes;
            }

            updateCell(cell, r, c) {
                cell.className = this.getCellClasses(r, c);
                const symbol = this.game.gridData[r][c];
                
                cell.innerHTML = ''; 
                cell.style.setProperty('--hero-symbol', `'${this.game.heroSymbol}'`);

                if (symbol) {
                    const symbolSpan = document.createElement('span');
                    symbolSpan.textContent = symbol;
                    if(this.game.SYMBOL_COLORS[symbol]) {
                       symbolSpan.className = this.game.SYMBOL_COLORS[symbol];
                    }
                    cell.appendChild(symbolSpan);
                } else {
                    cell.innerHTML = '';
                }
            }

            updateFullGrid() { for (let r = 0; r < this.game.GRID_SIZE; r++) for (let c = 0; c < this.game.GRID_SIZE; c++) this.updateGridCell(r, c); }
            updateGridCell(r, c) { if (this.gridCells[r]?.[c]) this.updateCell(this.gridCells[r][c], r, c); }

            renderScorePlaceholders() {
                this.DOMElements.row_scores_display.innerHTML = ''; 
                this.DOMElements.col_scores_display.innerHTML = '';
                for (let i = 0; i < this.game.GRID_SIZE; i++) {
                    const rowScore = document.createElement('div'); rowScore.id = `row-score-${i}`; rowScore.className = 'grid-cell score-display-cell'; rowScore.textContent = '0'; this.DOMElements.row_scores_display.appendChild(rowScore);
                    const colScore = document.createElement('div'); colScore.id = `col-score-${i}`; colScore.className = 'grid-cell score-display-cell'; colScore.textContent = '0'; this.DOMElements.col_scores_display.appendChild(colScore);
                }
            }

            renderControls() {
                const inGameContent = this.DOMElements.in_game_content;
                const preGameContent = this.DOMElements.pre_game_content;
                
                if(inGameContent) inGameContent.className = '';

                if (this.game.gameStateManager.is('PRE_GAME')) {
                    if(preGameContent) preGameContent.style.display = 'block';
                    if(inGameContent) inGameContent.style.display = 'none';
                } else {
                    if(preGameContent) preGameContent.style.display = 'none';
                    if(inGameContent) inGameContent.style.display = 'block';
                    this.renderDiceAndPowers();
                }
            }

            renderDiceAndPowers() {
                const container = this.DOMElements.in_game_content;
                container.className = '';
                container.innerHTML = '';
                
                const wrapper = document.createElement('div');
                let timerHTML = '';
                if(this.game.isTimeBurst) {
                    timerHTML = `<div id="timer-display" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card enhanced-shadow flex items-center justify-center text-2xl lg:text-3xl font-bold" style="color: var(--accent);" aria-live="polite">${this.game.timeLeft}</div>`;
                }

                wrapper.innerHTML = `<div class="w-full flex flex-col justify-start gap-4">
                    <div class="flex justify-center items-center gap-2 lg:gap-4">
                        <button id="roll-dice-btn" aria-label="Roll Dice" class="w-14 h-14 lg:w-16 lg:h-16 text-4xl lg:text-5xl flex items-center justify-center" style="color: var(--accent);">🎲</button>
                        <div id="dice-1" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card enhanced-shadow flex items-center justify-center text-3xl lg:text-4xl shimmer-text">?</div>
                        <div id="dice-2" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card enhanced-shadow flex items-center justify-center text-3xl lg:text-4xl shimmer-text">?</div>
                        ${timerHTML}
                    </div>
                    <div>
                        <h2 class="text-sm font-semibold uppercase tracking-wider mb-2 flex items-center justify-center gap-2" style="color: var(--text-secondary);">
                            Alloha Superpowers <span id="sp-charges" class="text-base">✨✨</span>
                        </h2>
                        <div class="grid grid-cols-4 gap-1 text-center">
                            <button id="past-lives-btn" class="superpower-btn"><div>Past</div><div>Lives</div><div class="superpower-used-overlay hidden absolute inset-0 text-red-500 text-4xl font-extrabold flex items-center justify-center" style="text-shadow: 0 1px 2px rgba(0,0,0,0.4);">X</div></button>
                            <button id="no-return-btn" class="superpower-btn"><div>No</div><div>Return</div><div class="superpower-used-overlay hidden absolute inset-0 text-red-500 text-4xl font-extrabold flex items-center justify-center" style="text-shadow: 0 1px 2px rgba(0,0,0,0.4);">X</div></button>
                            <button id="bomb-bae-btn" class="superpower-btn"><div>Bomb</div><div>Bae</div><div class="superpower-used-overlay hidden absolute inset-0 text-red-500 text-4xl font-extrabold flex items-center justify-center" style="text-shadow: 0 1px 2px rgba(0,0,0,0.4);">X</div></button>
                            <button id="swap-them-btn" class="superpower-btn"><div>Swap</div><div>Them</div><div class="superpower-used-overlay hidden absolute inset-0 text-red-500 text-4xl font-extrabold flex items-center justify-center" style="text-shadow: 0 1px 2px rgba(0,0,0,0.4);">X</div></button>
                        </div>
                    </div>
                </div>`;

                container.appendChild(wrapper);

                this.DOMElements.roll_dice_btn = document.getElementById('roll-dice-btn');
                this.DOMElements.dice_1 = document.getElementById('dice-1');
                this.DOMElements.dice_2 = document.getElementById('dice-2');
                this.DOMElements.timer_display = document.getElementById('timer-display');
                this.DOMElements.past_lives_btn = document.getElementById('past-lives-btn');
                this.DOMElements.no_return_btn = document.getElementById('no-return-btn');
                this.DOMElements.bomb_bae_btn = document.getElementById('bomb-bae-btn');
                this.DOMElements.swap_them_btn = document.getElementById('swap-them-btn');
                this.DOMElements.sp_charges = document.getElementById('sp-charges');

                this.updateControlsState();
                this.game.inputHandler.attachSuperpowerEventListeners();
                this.updateSuperpowerButtonsUI();
                if(this.game.isTimeBurst) this.updateTimerDisplay();
            }

            updateControlsState() {
                if (this.game.gameStateManager.is('PRE_GAME')) return;
                const rollBtn = this.DOMElements.roll_dice_btn;
                if (rollBtn) {
                    rollBtn.classList.toggle('bob-animation', this.game.gameStateManager.is('AWAITING_ROLL'));
                }
                const dice1 = this.DOMElements.dice_1, dice2 = this.DOMElements.dice_2;
                if (!dice1 || !dice2) return;
                
                dice1.classList.remove('shimmer-text');
                dice2.classList.remove('shimmer-text');
                
                if (this.game.gameStateManager.is('AWAITING_PLACEMENT') && this.game.currentRoll.length === 2) {
                    const symbol1 = this.game.currentRoll[0], symbol2 = this.game.currentRoll[1];
                    const color1 = this.game.SYMBOL_COLORS[symbol1] || 'text-gray-700';
                    const color2 = this.game.SYMBOL_COLORS[symbol2] || 'text-gray-700';

                    dice1.innerHTML = `<span class="${color1}">${symbol1}</span>`;
                    dice2.innerHTML = `<span class="${color2}">${symbol2}</span>`;
                } else {
                    dice1.textContent = '?';
                    dice2.textContent = '?';
                    dice1.classList.add('shimmer-text');
                    dice2.classList.add('shimmer-text');
                }
            }

            updateScoreDisplays(r, c, cross, b, h, p) { 
                animateScoreUpdate('total-score', r + c + cross + b + h + p, 3); 
                animateScoreUpdate('rows-total-score', r, 2); 
                animateScoreUpdate('cols-total-score', c, 2); 
                animateScoreUpdate('cross-total-score', cross, 2); 
                animateScoreUpdate('bonus-grid-score', b, 2);
                animateScoreUpdate('hero-bonus-score', h, 2);
                animateScoreUpdate('empty-block-penalty', p, 2); 
            }
            
            updateIndividualScores(rS, cS) { 
                rS.forEach((s, i) => this.updateScoreElement(`row-score-${i}`, s)); 
                cS.forEach((s, i) => this.updateScoreElement(`col-score-${i}`, s)); 
            }
            
            updateScoreElement(id, score) { 
                const el = document.getElementById(id); // Individual score elements are dynamically created
                if (el) { 
                    const oldScore = parseInt(el.textContent);
                    el.textContent = score; 
                    el.classList.toggle('text-red-500', score < 0); 
                    if (score < 0 && oldScore >= 0) {
                        this.game.triggerVibration([70, 40, 70]);
                    }
                } 
            }
            
            updateSuperpowerButtonsUI() {
                const ids = {
                    [SUPERPOWERS.PAST_LIVES]: this.DOMElements.past_lives_btn,
                    [SUPERPOWERS.NO_RETURN]: this.DOMElements.no_return_btn,
                    [SUPERPOWERS.BOMB_BAE]: this.DOMElements.bomb_bae_btn,
                    [SUPERPOWERS.SWAP_THEM]: this.DOMElements.swap_them_btn,
                };
                Object.values(ids).forEach(btn => {
                    if (!btn) return;
                    const overlay = btn.querySelector('.superpower-used-overlay');
                    const powerKey = Object.keys(ids).find(key => ids[key] === btn);
                    if(this.game.usedSuperpowers.has(powerKey)) {
                        if(overlay) overlay.classList.remove('hidden');
                    } else {
                        if(overlay) overlay.classList.add('hidden');
                    }
                });

                const totalUsed = this.game.usedSuperpowers.size, isMidMove = this.game.firstPlacementCell !== null, isPowerActive = this.game.activeSuperpower !== null, isAwaitingRoll = this.game.gameStateManager.is('AWAITING_ROLL');
                const btns = { 
                    [SUPERPOWERS.PAST_LIVES]: this.DOMElements.past_lives_btn, 
                    [SUPERPOWERS.BOMB_BAE]: this.DOMElements.bomb_bae_btn, 
                    [SUPERPOWERS.NO_RETURN]: this.DOMElements.no_return_btn, 
                    [SUPERPOWERS.SWAP_THEM]: this.DOMElements.swap_them_btn
                };
                
                if (btns[SUPERPOWERS.PAST_LIVES]) btns[SUPERPOWERS.PAST_LIVES].disabled = totalUsed >= 2 || this.game.usedSuperpowers.has(SUPERPOWERS.PAST_LIVES) || !this.game.lastGameState || isMidMove || isPowerActive || !isAwaitingRoll;
                if (btns[SUPERPOWERS.BOMB_BAE]) btns[SUPERPOWERS.BOMB_BAE].disabled = totalUsed >= 2 || this.game.usedSuperpowers.has(SUPERPOWERS.BOMB_BAE) || this.game.gridData.flat().every(s => s === null) || isMidMove || isPowerActive;
                if (btns[SUPERPOWERS.NO_RETURN]) btns[SUPERPOWERS.NO_RETURN].disabled = this.game.turnCount < 1 || totalUsed >= 2 || this.game.usedSuperpowers.has(SUPERPOWERS.NO_RETURN) || isMidMove || isPowerActive;
                if (btns[SUPERPOWERS.SWAP_THEM]) btns[SUPERPOWERS.SWAP_THEM].disabled = this.game.turnCount < 1 || totalUsed >= 2 || this.game.usedSuperpowers.has(SUPERPOWERS.SWAP_THEM) || !isAwaitingRoll || isMidMove || isPowerActive;
                
                Object.values(btns).forEach(btn => { if(btn) btn.classList.remove('superpower-btn--active')});
                if (isPowerActive && btns[this.game.activeSuperpower]) {
                    btns[this.game.activeSuperpower].classList.add('superpower-btn--active');
                }
                document.body.style.cursor = this.game.activeSuperpower === SUPERPOWERS.BOMB_BAE ? 'crosshair' : '';

                const spChargesEl = this.DOMElements.sp_charges;
                if (spChargesEl) {
                    if (totalUsed === 0) {
                        spChargesEl.innerHTML = '✨✨';
                    } else if (totalUsed === 1) {
                        spChargesEl.innerHTML = '✨<span class="opacity-30">✨</span>';
                    } else {
                        spChargesEl.innerHTML = '<span class="opacity-30">✨✨</span>';
                    }
                }
            }
            
            syncPanelHeights() { setTimeout(() => { if (window.innerWidth < 1024) return; const boardHeight = this.DOMElements.game_board_container?.getBoundingClientRect().height; if (boardHeight) this.DOMElements.scoring_panel.style.height = `${boardHeight}px`; }, 50); }
            
            updateProgressBar() {
                if (!this.DOMElements.progress_bar_fill) return;
                const percentage = (this.game.turnCount / this.game.MAX_TURNS) * 100;
                this.DOMElements.progress_bar_fill.style.width = `${percentage}%`;
            }

            flashTwinningPattern() {
                const highlightedCells = document.querySelectorAll('.highlighted');
                if (highlightedCells.length === 0) return;

                highlightedCells.forEach(cell => {
                    cell.classList.add('twinning-flash-animation');
                });
                setTimeout(() => {
                    highlightedCells.forEach(cell => {
                        cell.classList.remove('twinning-flash-animation');
                    });
                }, CONSTANTS.TWINNING_FLASH_DURATION);
            }

            showCurseEffect(cellElement) {
                const board = this.DOMElements.game_board_container;
                board.classList.add('shake-animation');
                setTimeout(() => board.classList.remove('shake-animation'), CONSTANTS.SHAKE_ANIMATION_DURATION);

                const overlay = document.createElement('div');
                overlay.textContent = '☠️';
                overlay.className = 'curse-overlay';
                
                const rect = cellElement.getBoundingClientRect();
                overlay.style.top = `${rect.top}px`;
                overlay.style.left = `${rect.left}px`;
                overlay.style.width = `${rect.width}px`;
                overlay.style.height = `${rect.height}px`;
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';

                document.body.appendChild(overlay);
                setTimeout(() => overlay.remove(), CONSTANTS.CURSE_EFFECT_DURATION);
            }

            highlightValidPlacements(r, c) {
                const adjacent = [ [r-1, c], [r+1, c], [r, c-1], [r, c+1] ];
                adjacent.forEach(([nr, nc]) => {
                    if (nr >= 0 && nr < this.game.GRID_SIZE && nc >= 0 && nc < this.game.GRID_SIZE && !this.game.gridData[nr][nc]) {
                        const cell = this.gridCells[nr][nc];
                        cell.classList.add('valid-placement');
                    }
                });
            }

            clearPlacementHighlights() {
                this.gridCells.flat().forEach(cell => {
                    cell.classList.remove('valid-placement');
                });
            }

            renderGoldenAllohaPlacementPrompt(symbol) {
                const container = this.DOMElements.in_game_content;
                container.className = 'flex items-center justify-center h-full';
                container.innerHTML = '';

                const wrapper = document.createElement('div');
                wrapper.className = 'text-center';

                const line1 = document.createElement('h2');
                line1.className = 'text-xl lg:text-2xl font-semibold text-center';
                line1.style.color = 'var(--accent)';
                line1.innerHTML = `You chose <span class="text-5xl align-middle ${this.game.SYMBOL_COLORS[symbol] || 'text-gray-700'}">${symbol}</span>`;

                const line2 = document.createElement('p');
                line2.className = 'text-base lg:text-lg font-medium mt-2 text-center';
                line2.style.color = 'var(--text-secondary)';
                line2.textContent = 'Place it on any highlighted Allohome!';

                wrapper.appendChild(line1);
                wrapper.appendChild(line2);
                container.appendChild(wrapper);
            }

            renderEndGamePanel(score) {
                const container = this.DOMElements.in_game_content;
                container.className = 'flex items-center justify-center h-full';
                container.innerHTML = '';

                const wrapper = document.createElement('div');
                wrapper.className = 'text-center';

                const title = document.createElement('h2');
                title.className = 'text-3xl font-bold text-center';
                title.style.fontFamily = "'Pacifico', cursive";
                title.style.color = 'var(--accent)';
                title.textContent = 'Game Over Alloha!';

                const scoreDisplay = document.createElement('div');
                scoreDisplay.id = 'end-game-score-display';
                scoreDisplay.className = 'text-7xl font-bold my-2 text-center';
                scoreDisplay.style.color = 'var(--accent)';
                
                wrapper.appendChild(title);
                wrapper.appendChild(scoreDisplay);
                container.appendChild(wrapper);
                
                animateScoreUpdate('end-game-score-display', score, 3);
            }

            async renderGoldenAllohaSelector() {
                const container = this.DOMElements.in_game_content;
                container.className = 'flex items-center justify-center h-full';
                container.innerHTML = '';

                return new Promise(resolve => {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'w-full flex flex-col items-center justify-center h-full gap-4';
                    
                    const title = document.createElement('h2');
                    title.className = 'text-base lg:text-lg font-semibold text-center uppercase tracking-wider';
                    title.style.color = 'var(--accent)';
                    title.textContent = 'Choose Last Alloha';

                    const selector = document.createElement('div');
                    selector.className = 'grid grid-cols-3 gap-2 lg:gap-4';

                    this.game.SYMBOLS.forEach(symbol => {
                        const btn = document.createElement('button');
                        btn.className = `w-12 h-12 lg:w-14 lg:h-14 rounded-xl text-3xl flex items-center justify-center transition-transform hover:scale-110 active:scale-95`;
                        const symbolSpan = document.createElement('span');
                        // CORRECTED: Added h-full to the span
                        symbolSpan.className = `${this.game.SYMBOL_COLORS[symbol] || ''} h-full flex items-center`;
                        symbolSpan.textContent = symbol;

                        btn.appendChild(symbolSpan);
                        btn.addEventListener('click', () => resolve(symbol));
                        selector.appendChild(btn);
                    });

                    wrapper.appendChild(title);
                    wrapper.appendChild(selector);
                    container.appendChild(wrapper);
                });
            }
            
            showSymbolSelectorForExchange(r, c) {
                 this.game.cellToExchange = {r, c}; this.DOMElements.exchange_options.innerHTML = '';
                 this.game.SYMBOLS.filter(s => s !== this.game.gridData[r][c]).forEach(symbol => {
                    const btn = document.createElement('button');
                    btn.className = `w-20 h-20 text-4xl rounded-lg hover:bg-orange-100/50 flex items-center justify-center`;
                    const symbolSpan = document.createElement('span');
                    symbolSpan.className = this.game.SYMBOL_COLORS[symbol] || '';
                    symbolSpan.textContent = symbol;
                    btn.appendChild(symbolSpan);
                    btn.addEventListener('click', () => this.game.handleSymbolExchange(symbol));
                    this.DOMElements.exchange_options.appendChild(btn);
                 });
                 handleModalOpen(this.DOMElements.exchange_modal);
            }
            
            triggerBoardAndFloatAnimations(scoredLines, lastMoveCoords) {
                if (!scoredLines || !lastMoveCoords) return;
                const lastMoveSet = new Set(lastMoveCoords.map(c => `${c.r},${c.c}`));

                scoredLines.forEach(line => {
                    const isNewlyFormed = line.cells.some(cell => lastMoveSet.has(`${cell.r},${cell.c}`));
                    if (line.score > 0 && isNewlyFormed) {
                        if (!this.game.vibratedForScoreThisTurn) {
                            this.game.triggerVibration(40);
                            this.game.vibratedForScoreThisTurn = true;
                        }
                        const sourceCell = this.gridCells[line.cells[Math.floor(line.cells.length / 2)].r][line.cells[Math.floor(line.cells.length / 2)].c];
                        showFloatingScore(`+${line.score}`, sourceCell);
                        line.cells.forEach(coord => {
                            const cellEl = this.gridCells[coord.r][coord.c];
                            cellEl.classList.add('score-pulse-animation');
                            cellEl.addEventListener('animationend', () => cellEl.classList.remove('score-pulse-animation'), { once: true });
                        });
                    }
                });
            }
            
            triggerConfetti() {
                const container = this.DOMElements.effects_container;
                if (!container) return;
                const colors = ['#E57373', '#FF8A65', '#FFC107', '#FFF176'];
                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti-piece';
                    confetti.style.left = `${Math.random() * 100}%`;
                    confetti.style.animation = `confetti-fall ${1.5 + Math.random() * 2}s ${Math.random() * 2}s linear forwards`;
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    container.appendChild(confetti);
                    setTimeout(() => confetti.remove(), CONSTANTS.CONFETTI_DURATION);
                }
            }

            updateTimerDisplay() {
                const timerEl = this.DOMElements.timer_display;
                if (timerEl) {
                    timerEl.textContent = this.game.timeLeft;
                }
            }
        }

        class InputHandler {
            constructor(game, DOMElements) {
                this.game = game;
                this.DOMElements = DOMElements;
                // Bind 'this' and store the function references to be able to remove them later
                this.handleContentClick = this._handleContentClick.bind(this);
                this.handleBoardClick = this._handleBoardClick.bind(this);
                this.handleResize = this.game.renderer.syncPanelHeights.bind(this.game.renderer);
                this.superpowerHandlers = new Map();
            }
        
            _handleContentClick(e) {
                if (e.target.closest('#roll-dice-btn')) this.handleRollDice();
            }
        
            _handleBoardClick(e) {
                const cell = e.target.closest('[data-row]');
                if (cell) this.handleCellClick(cell);
            }

            attachAllListeners() {
                this.DOMElements.in_game_content_wrapper.addEventListener('click', this.handleContentClick);
                this.DOMElements.game_board.addEventListener('click', this.handleBoardClick);
                window.addEventListener('resize', this.handleResize);
            }

            detachSuperpowerEventListeners() {
                for (const [key, {btn, handler}] of this.superpowerHandlers.entries()) {
                    if (btn) {
                        btn.removeEventListener('click', handler);
                    }
                }
                this.superpowerHandlers.clear();
            }

            detachAllListeners() {
                this.DOMElements.in_game_content_wrapper.removeEventListener('click', this.handleContentClick);
                this.DOMElements.game_board.removeEventListener('click', this.handleBoardClick);
                window.removeEventListener('resize', this.handleResize);
                this.detachSuperpowerEventListeners();
            }
            
            addCellEventListeners(cell) { 
                // This method is now only a placeholder if direct binding is needed, 
                // but we are using event delegation from attachAllListeners.
            }
            
            attachSuperpowerEventListeners() {
                // Clean up old listeners first
                this.detachSuperpowerEventListeners();
                
                // Past Lives button - special handling
                if (this.DOMElements.past_lives_btn) {
                    const pastLivesHandler = () => {
                        if (this.DOMElements.past_lives_btn.disabled) return;
                        this.game.audioManager.play('power-activate');
                        this.game.triggerVibration(30);

                        const state = this.game.lastGameState;
                        this.game.gridData = JSON.parse(state.gridData);
                        this.game.currentRoll = state.currentRoll;
                        this.game.firstPlacementCell = state.firstPlacementCell;
                        this.game.turnCount = state.turnCount;
                        this.game.stuckBlocks = new Set(state.stuckBlocks);
                        this.game.gameStateManager.currentState = state.currentState;
                        this.game.timeLeft = state.timeLeft;

                        this.game.renderer.updateFullGrid();
                        this.game.renderer.updateControlsState();
                        this.game.updateAllScores();
                        this.game.renderer.updateProgressBar();
                        
                        this.game.consumeSuperpower(SUPERPOWERS.PAST_LIVES);
                    };
                    this.superpowerHandlers.set('past_lives', { 
                        btn: this.DOMElements.past_lives_btn, 
                        handler: pastLivesHandler 
                    });
                    this.DOMElements.past_lives_btn.addEventListener('click', pastLivesHandler);
                }

                // Other superpower buttons
                const powerBtns = { 
                    [SUPERPOWERS.BOMB_BAE]: this.DOMElements.bomb_bae_btn, 
                    [SUPERPOWERS.NO_RETURN]: this.DOMElements.no_return_btn, 
                    [SUPERPOWERS.SWAP_THEM]: this.DOMElements.swap_them_btn
                };
                
                for (const [power, btn] of Object.entries(powerBtns)) { 
                    if (btn) {
                        const handler = () => {
                            if (btn.disabled) return;
                            this.game.activeSuperpower = power;
                            this.game.gameStateManager.setState('SUPERPOWER_ACTIVE');
                            this.game.audioManager.play('power-activate');
                            this.game.triggerVibration(30);
                            this.game.renderer.updateSuperpowerButtonsUI();
                        };
                        this.superpowerHandlers.set(power, { btn, handler });
                        btn.addEventListener('click', handler);
                    }
                }
            }

            handleCellClick(cell) {
                const r = parseInt(cell.dataset.row), c = parseInt(cell.dataset.col);

                if (this.game.activeSuperpower) { this.handleSuperpowerCellClick(r, c, cell); return; }
                if (!this.game.gameStateManager.is('AWAITING_PLACEMENT')) return;
                if (this.game.firstPlacementCell) { this.handleSecondPlacement(r, c, cell); } else { this.handleFirstPlacement(r, c); }
            }

            handleFirstPlacement(r, c) { 
                if (!this.game.gridData[r][c]) { 
                    this.game.gridData[r][c] = this.game.currentRoll[0]; 
                    this.game.firstPlacementCell = { r, c }; 
                    this.game.renderer.updateGridCell(r, c); 
                    this.game.renderer.highlightValidPlacements(r, c);
                    this.game.renderer.updateSuperpowerButtonsUI(); 
                } 
            }

            handleSecondPlacement(r, c, cell) {
                const { r: pR, c: pC } = this.game.firstPlacementCell;
                if (pR === r && pC === c) { 
                    this.game.gridData[r][c] = null; 
                    this.game.firstPlacementCell = null; 
                    this.game.renderer.updateGridCell(r, c); 
                    this.game.renderer.clearPlacementHighlights();
                    this.game.renderer.updateSuperpowerButtonsUI(); 
                    return; 
                }
                if ((Math.abs(pR - r) + Math.abs(pC - c) === 1) && !this.game.gridData[r][c]) { 
                    this.game.renderer.clearPlacementHighlights();
                    this.game.completeMove(r, c); 
                }
                else { 
                    cell.classList.add('shake-animation'); 
                    setTimeout(() => cell.classList.remove('shake-animation'), CONSTANTS.SHAKE_ANIMATION_DURATION); 
                    this.game.audioManager.play('invalid'); 
                }
            }

            async handleRollDice() {
                if (this.game.gameStateManager.is('GAME_OVER')) {
                    handleModalOpen(this.game.DOMElements.post_game_modal);
                    return;
                }
                gameManager.unlockAudioContext();
                if (this.game.gameStateManager.is('AWAITING_PLACEMENT')) {
                    handleModalOpen(this.game.DOMElements.warning_modal);
                    return;
                }
                if (!this.game.gameStateManager.is('AWAITING_ROLL')) return;
                
                this.game.triggerVibration(50);

                if (this.game.turnCount >= this.game.MAX_TURNS || !this.game.hasValidMoves()) {
                    this.game.startGoldenAllohaSequence();
                    return;
                }

                this.game.gameStateManager.setState('ANIMATING_ROLL');
                if (this.game.isTimeBurst && !this.game.timerId) { this.game.startTimer(); }

                const d1 = this.DOMElements.dice_1, d2 = this.DOMElements.dice_2;
                this.game.renderer.updateControlsState();
                d1.classList.add('dice-tumble');
                d2.classList.add('dice-tumble');

                const nextTurn = this.game.turnCount + 1; let tempRoll;
                if (nextTurn === this.game.cursedBlockTurn) { this.game.audioManager.play('thud'); tempRoll = [this.game.SYMBOLS[Math.floor(Math.random() * this.game.SYMBOLS.length)], this.game.SPECIAL_SYMBOLS.CURSED]; }
                else if (nextTurn === this.game.wildcardTurn) { this.game.audioManager.play('chime'); tempRoll = [this.game.SYMBOLS[Math.floor(Math.random() * this.game.SYMBOLS.length)], this.game.SPECIAL_SYMBOLS.WILD]; }
                else { this.game.audioManager.play('roll'); tempRoll = [this.game.SYMBOLS[Math.floor(Math.random() * this.game.SYMBOLS.length)], this.game.SYMBOLS[Math.floor(Math.random() * this.game.SYMBOLS.length)]]; }
                
                this.game.currentRoll = tempRoll.sort(() => Math.random() - 0.5);
                
                await delay(CONSTANTS.DICE_TUMBLE_DURATION);
                                
                this.game.gameStateManager.setState('AWAITING_PLACEMENT');
                this.game.saveStateForUndo(); 
                this.game.renderer.updateControlsState(); 
                this.game.renderer.updateSuperpowerButtonsUI();
            }

            handleSuperpowerCellClick(r, c, cell) {
                if (this.game.gridData[r][c] === this.game.SPECIAL_SYMBOLS.CURSED || this.game.gridData[r][c] === this.game.SPECIAL_SYMBOLS.STUCK) {
                    this.game.audioManager.play('invalid');
                    cell.classList.add('shake-animation');
                    setTimeout(() => cell.classList.remove('shake-animation'), CONSTANTS.SHAKE_ANIMATION_DURATION);
                    return;
                }

                const strategy = this.game._superpowerStrategies[this.game.activeSuperpower];
                if (strategy) {
                    strategy(r, c, cell);
                } else {
                    this.game.audioManager.play('invalid');
                }
            }
        }
        
        // --- Game class now defined AFTER its dependencies ---
        class Game {
            constructor(variantConfig, themeConfig, isTimeBurst, allVariantConfigs, savedState = null) {
                this.config = variantConfig;
                this.theme = themeConfig;
                this.isTimeBurst = isTimeBurst;
                this.allVariantConfigs = allVariantConfigs;
                
                this.SYMBOLS = this.theme.symbols;
                this.SYMBOL_COLORS = this.theme.symbolColors;
                this.SPECIAL_SYMBOLS = { 'WILD': '💎', 'CURSED': '☠️', 'STUCK': '💣' };
                this.SCORING_RULES = { 7: 20, 6: 12, 5: 8, 4: 5, 3: 3 };
                this.GRID_SIZE = 7; this.MAX_TURNS = 24; this.CROSS_MULTIPLIER = 2; this.LINE_DEATH_PENALTY = -5; this.CROSS_DEATH_PENALTY = -5; this.MIN_SEQUENCE_LENGTH = 3;

                this.DOMElements = this._getDOMElements();
                this.audioManager = new AudioManager();
                this.renderer = new Renderer(this, this.DOMElements);
                this.inputHandler = new InputHandler(this, this.DOMElements);
                
                this._initializeState(savedState);
                this._setupUI();
                this.inputHandler.attachAllListeners();
            }

            _initializeState(savedState = null) {
                this.stopTimer();
                this.gridData = Array(this.GRID_SIZE).fill(null).map(() => Array(this.GRID_SIZE).fill(null));
                this.currentRoll = [];
                this.firstPlacementCell = null;
                this.turnCount = 0;
                this.stuckBlocks = new Set();
                this.usedSuperpowers = new Set();
                this.activeSuperpower = null;
                this.lastGameState = null;
                this.lastMoveCoords = null;
                this.currentTotalScore = 0;
                this.scores = { rows: 0, cols: 0, cross: 0, bonus: 0, hero: 0, penalty: 0 };
                this.gameStateManager = new GameState();
                this.vibratedForScoreThisTurn = false;
                this.cellToExchange = null;
                this.swapFirstCell = null;
                
                this.tutorialMode = false;
                this.tutorialStep = 0;

                if (savedState) {
                    this.gridData = JSON.parse(savedState.gridData);
                    this.currentRoll = savedState.currentRoll;
                    this.firstPlacementCell = savedState.firstPlacementCell;
                    this.turnCount = savedState.turnCount;
                    this.stuckBlocks = new Set(savedState.stuckBlocks);
                    this.usedSuperpowers = new Set(savedState.usedSuperpowers);
                    this.lastGameState = savedState.lastGameState ? { ...this.lastGameState, gridData: JSON.parse(savedState.lastGameState.gridData), stuckBlocks: new Set(savedState.lastGameState.stuckBlocks) } : null;
                    this.activeSuperpower = savedState.activeSuperpower;
                    this.currentTotalScore = savedState.currentTotalScore;
                    this.cursedBlockTurn = savedState.cursedBlockTurn;
                    this.wildcardTurn = savedState.wildcardTurn;
                    this.heroSymbol = savedState.heroSymbol;
                    this.heroBlocks = new Set(savedState.heroBlocks);
                    this.gameStateManager.currentState = savedState.currentState;
                    this.timeLeft = savedState.timeLeft;
                    if(this.isTimeBurst && this.turnCount > 0 && !this.gameStateManager.is('GAME_OVER')) this.startTimer();
                } else {
                    this.gameStateManager.setState('AWAITING_ROLL');
                    this.timeLeft = this.config.timeLimit;
                    this.cursedBlockTurn = Math.floor(Math.random() * 8) + 5;
                    this.wildcardTurn = Math.floor(Math.random() * 8) + 15;
                    if (this.wildcardTurn === this.cursedBlockTurn) this.wildcardTurn++;
                    this._initializeHeroFeature();
                    this._initTutorial();
                }

                const highScoreKey = `cactiFactiHighScore_${this.config.id}_${this.isTimeBurst ? 'timeburst' : 'classic'}`;
                this.highScore = parseInt(localStorage.getItem(highScoreKey)) || 0;
                
                this.audioManager.init();


                this._superpowerStrategies = {
                    [SUPERPOWERS.SWAP_THEM]: (r, c, cell) => {
                        if (!this.gridData[r][c] || this.gridData[r][c] === this.SPECIAL_SYMBOLS.CURSED) { this.audioManager.play('invalid'); return; }
                        if (!this.swapFirstCell) {
                            this.swapFirstCell = { r, c };
                            cell.classList.add('pulse-animation');
                        } else {
                            const { r: r1, c: c1 } = this.swapFirstCell;
                            if (r1 === r && c1 === c) { this.swapFirstCell = null; cell.classList.remove('pulse-animation'); return; }
                            if (Math.abs(r1 - r) + Math.abs(c1 - c) === 1) {
                                [this.gridData[r1][c1], this.gridData[r][c]] = [this.gridData[r][c], this.gridData[r1][c1]];
                                this.renderer.gridCells[r1][c1].classList.remove('pulse-animation');
                                this.swapFirstCell = null;
                                this.consumeSuperpower(SUPERPOWERS.SWAP_THEM);
                                this.gameStateManager.setState('AWAITING_ROLL');
                                this.renderer.renderControls();
                            } else {
                                this.audioManager.play('invalid');
                                cell.classList.add('shake-animation');
                                setTimeout(() => cell.classList.remove('shake-animation'), CONSTANTS.SHAKE_ANIMATION_DURATION);
                                this.renderer.gridCells[r1][c1].classList.remove('pulse-animation');
                                this.swapFirstCell = null;
                            }
                        }
                    },
                    [SUPERPOWERS.BOMB_BAE]: (r, c, cell) => {
                        const targetSymbol = this.gridData[r][c];
                        if (!targetSymbol || targetSymbol === this.SPECIAL_SYMBOLS.WILD) {
                            this.audioManager.play('invalid');
                            cell.classList.add('shake-animation');
                            setTimeout(() => cell.classList.remove('shake-animation'), CONSTANTS.SHAKE_ANIMATION_DURATION);
                            return;
                        }

                        // Apply gravity effect
                        for (let i = r; i > 0; i--) {
                            this.gridData[i][c] = this.gridData[i - 1][c];
                        }
                        this.gridData[0][c] = null;

                        this.consumeSuperpower(SUPERPOWERS.BOMB_BAE);
                        this.gameStateManager.setState('AWAITING_ROLL');
                        this.renderer.renderControls();
                    },
                    [SUPERPOWERS.NO_RETURN]: (r, c, cell) => {
                        if (this.gridData[r][c]) {
                            this.renderer.showSymbolSelectorForExchange(r, c);
                        } else {
                            this.audioManager.play('invalid');
                        }
                    }
                };
            }

            _setupUI() {
                animateScoreUpdate('high-score', this.highScore, 3);
                Object.values(this.DOMElements.modals).forEach(modal => {
                    if (modal) modal.classList.remove('is-open');
                });
                
                this.renderer.renderGrid().then(() => {
                    if (!this.lastGameState && this.turnCount === 0) {
                        this.renderer.flashTwinningPattern();
                    }
                });
                this.renderer.renderScorePlaceholders();
                this.renderer.renderControls();
                this.updateAllScores();
                this.renderer.updateProgressBar();
                this.renderer.syncPanelHeights();
            }

            _getDOMElements() {
                const elements = { modals: {} };
                const idMap = {
                    // Game Board & Scores
                    game_board: 'game-board',
                    row_scores_display: 'row-scores-display',
                    col_scores_display: 'col-scores-display',
                    total_score: 'total-score',
                    high_score: 'high-score',
                    rows_total_score: 'rows-total-score',
                    cols_total_score: 'cols-total-score',
                    cross_total_score: 'cross-total-score',
                    bonus_grid_score: 'bonus-grid-score',
                    empty_block_penalty: 'empty-block-penalty',
                    hero_bonus_score: 'hero-bonus-score',
                    progress_bar_fill: 'progress-bar-fill',
                    game_board_container: 'game-board-container',
                    scoring_panel: 'scoring-panel',
                    effects_container: 'effects-container',
                    in_game_content: 'in-game-content',
                    pre_game_content: 'pre_game-content',
                    in_game_content_wrapper: 'in-game-content-wrapper',
                    audio_unlocker: 'audio-unlocker',
                    post_game_modal: 'post-game-modal',
                    close_post_game_modal_btn: 'close-post-game-modal-btn',
                    post_game_play_again_btn: 'post-game-play-again-btn',
                    post_game_select_edition_btn: 'post-game-select-edition-btn',

                    // In-game controls (will be created dynamically but good to have keys)
                    dice_1: 'dice-1',
                    dice_2: 'dice-2',
                    roll_dice_btn: 'roll-dice-btn',
                    timer_display: 'timer-display',
                    past_lives_btn: 'past-lives-btn',
                    no_return_btn: 'no-return-btn',
                    bomb_bae_btn: 'bomb-bae-btn',
                    swap_them_btn: 'swap-them-btn',
                    sp_charges: 'sp-charges',

                    // Global Buttons
                    rules_btn: 'rules-btn',
                    new_game_btn: 'new-game-btn',
                    badges_btn: 'badges-btn',
                    select_edition_btn: 'select-edition-btn',

                    // Modals & Modal Content
                    rules_modal: 'rules-modal',
                    game_over_modal: 'game-over-modal',
                    exchange_modal: 'exchange-modal',
                    tutorial_modal: 'tutorial-modal',
                    warning_modal: 'warning-modal',
                    unlock_modal: 'unlock-modal',
                    badges_modal: 'badges-modal',
                    edition_select_modal: 'edition-select-modal',
                    confirm_restart_modal: 'confirm-restart-modal',

                    // Modal Buttons
                    close_rules_btn: 'close-rules-btn',
                    close_game_over_btn: 'close-game-over-btn',
                    play_again_btn: 'play-again-btn',
                    share_score_btn: 'share-score-btn',
                    change_edition_btn_modal: 'change-edition-btn-modal',
                    close_edition_select_btn: 'close-edition-select-btn',
                    confirm_cancel_btn: 'confirm-cancel-btn',
                    confirm_restart_btn: 'confirm-restart-btn',
                    close_tutorial_btn: 'close-tutorial-btn',
                    tutorial_next_btn: 'tutorial-next-btn',
                    close_warning_btn: 'close-warning-btn',
                    close_warning_x_btn: 'close-warning-x-btn',
                    close_unlock_btn: 'close-unlock-btn',
                    close_unlock_x_btn: 'close-unlock-x-btn',
                    close_badges_btn: 'close-badges-btn',
                    share_badges_btn: 'share-badges-btn',
                    
                    // Modal Specific Content
                    rules_title: 'rules-title',
                    game_over_reason: 'game-over-reason',
                    final_score_modal: 'final-score-modal',
                    high_score_modal: 'high-score-modal',
                    final_rows_score: 'final-rows-score',
                    final_cols_score: 'final-cols-score',
                    final_cross_score: 'final-cross-score',
                    final_bonus_score: 'final-bonus-score',
                    final_hero_score: 'final-hero-score',
                    final_penalty_score: 'final-penalty-score',
                    exchange_options: 'exchange-options',
                    tutorial_content: 'tutorial-content',
                    unlocked_edition_name: 'unlocked-edition-name',
                    badges_grid: 'badges-grid',
                    badge_info_text: 'badge-info-text',
                    edition_options: 'edition-options',
                    mode_toggle_switch: 'mode-toggle-switch',
                    classic_text: 'classic-text',
                    time_burst_text: 'time-burst-text',
                };
                
                for (const key in idMap) {
                    const element = document.getElementById(idMap[key]);
                    if (!element) {
                        // This warning is helpful during development but can be noisy if elements are dynamically created
                        // console.warn(`[Alloha Dev Warning] DOM element not found for key: "${key}" with ID: "${idMap[key]}"`);
                    }
                    if (key.endsWith('_modal')) {
                        elements.modals[key] = element;
                    }
                    elements[key] = element;
                }
                
                // For elements without a simple ID, query them here too
                elements.modal_content_badges = document.querySelector('#badges-modal .modal-content');
                elements.modal_content_game_over = document.querySelector('#game-over-modal .modal-content');
                
                return elements;
            }

            _initializeHeroFeature() {
                this.heroSymbol = this.SYMBOLS[Math.floor(Math.random() * this.SYMBOLS.length)];
                this.heroBlocks = new Set();
                while (this.heroBlocks.size < 7) {
                    const r = Math.floor(Math.random() * this.GRID_SIZE);
                    const c = Math.floor(Math.random() * this.GRID_SIZE);
                    this.heroBlocks.add(`${r},${c}`);
                }
            }

            _initTutorial() {
                if (localStorage.getItem('allohaTutorialCompleted')) return;
                
                this.tutorialMode = true;
                this.tutorialStep = 0;
                setTimeout(() => this.showTutorialStep(), 1000);
            }

            showTutorialStep() {
                const steps = [
                    {
                        title: "Welcome to Alloha!",
                        content: "Let's learn how to play. Click the dice button to roll your first pair!",
                    },
                    {
                        title: "Place Your Allohas",
                        content: "Click on an empty cell to place your first symbol, then an adjacent cell for the second.",
                    },
                    {
                        title: "Create Lines",
                        content: "Match 3 or more symbols in a row or column to score points!",
                    },
                    {
                        title: "Special Patterns",
                        content: "Highlighted cells give bonus points when you create lines through them!",
                    }
                ];

                if (this.tutorialStep >= steps.length) {
                    this.completeTutorial();
                    return;
                }

                const step = steps[this.tutorialStep];
                this.updateTutorialModal(step);
            }

            updateTutorialModal(step) {
                const modal = this.DOMElements.tutorial_modal;
                const content = this.DOMElements.tutorial_content;
                const nextBtn = this.DOMElements.tutorial_next_btn;
                const progressDots = modal.querySelectorAll('.tutorial-progress-dot');
                
                content.innerHTML = `<p class="text-lg">${step.content}</p>`;
                
                progressDots.forEach((dot, index) => {
                    dot.classList.toggle('active', index === this.tutorialStep);
                });
                
                nextBtn.textContent = this.tutorialStep === 3 ? "Start Playing" : "Next";
                
                handleModalOpen(modal);
            }

            completeTutorial() {
                this.tutorialMode = false;
                localStorage.setItem('allohaTutorialCompleted', 'true');
                handleModalClose(this.DOMElements.tutorial_modal);
            }

            getState() {
                return {
                    gridData: JSON.stringify(this.gridData),
                    currentRoll: this.currentRoll,
                    firstPlacementCell: this.firstPlacementCell,
                    turnCount: this.turnCount,
                    stuckBlocks: [...this.stuckBlocks],
                    usedSuperpowers: [...this.usedSuperpowers],
                    lastGameState: this.lastGameState ? { ...this.lastGameState, gridData: JSON.stringify(this.lastGameState.gridData), stuckBlocks: new Set(this.lastGameState.stuckBlocks) } : null,
                    activeSuperpower: this.activeSuperpower,
                    currentTotalScore: this.currentTotalScore,
                    cursedBlockTurn: this.cursedBlockTurn,
                    wildcardTurn: this.wildcardTurn,
                    heroSymbol: this.heroSymbol,
                    heroBlocks: [...this.heroBlocks],
                    currentState: this.gameStateManager.currentState,
                    timeLeft: this.timeLeft,
                    isTimeBurst: this.isTimeBurst
                };
            }

            triggerVibration(patternOrDuration = 10) { if (navigator.vibrate) { navigator.vibrate(patternOrDuration); } }

            startTimer() {
                if (this.timerId || this.gameStateManager.is('GAME_OVER')) return;
                
                if (this.isTimeBurst) {
                    let stats = getPlayerStats();
                    if (!stats.timeBurstGamesPlayed || stats.timeBurstGamesPlayed === 0) {
                        unlockBadge('timeTraveller', stats);
                    }
                    stats.timeBurstGamesPlayed = (stats.timeBurstGamesPlayed || 0) + 1;
                    savePlayerStats(stats);
                }

                this.renderer.updateTimerDisplay();
                this.timerId = setInterval(() => {
                    if (this.gameStateManager.is('GAME_OVER')) {
                        this.stopTimer();
                        return;
                    }
                    this.timeLeft--;
                    this.renderer.updateTimerDisplay();
                    if (this.timeLeft <= 0) {
                        this.endGame("Time's up!");
                    }
                }, 1000);
            }

            stopTimer() {
                if (this.timerId) {
                    clearInterval(this.timerId);
                    this.timerId = null;
                }
            }

            calculateLineScore(line, lineType, index) {
                let totalScore = 0; const usedIndices = new Set(); const scoredLines = [];
                for (let len = this.GRID_SIZE; len >= this.MIN_SEQUENCE_LENGTH; len--) {
                    for (let i = 0; i <= this.GRID_SIZE - len; i++) {
                        if ([...Array(len).keys()].some(k => usedIndices.has(i + k))) continue;
                        const slice = line.slice(i, i + len);
                        if (this.isValidSequence(slice)) {

                            if (len === 7) {
                                unlockBadge('perfectionist');
                            }

                            const score = this.SCORING_RULES[len];
                            totalScore += score;
                            const cells = [];
                            for (let k = 0; k < len; k++) {
                                if (slice[k] !== this.SPECIAL_SYMBOLS.WILD) usedIndices.add(i + k);
                                cells.push(lineType === 'row' ? {r: index, c: i + k} : {r: i + k, c: index});
                            }
                            scoredLines.push({ score, cells });
                        }
                    }
                }
                if (totalScore === 0 && this.isLineDead(line)) return { total: this.LINE_DEATH_PENALTY, lines: [] };
                return { total: totalScore, lines: scoredLines };
            }

            isValidSequence(slice) {
                if (slice.some(s => s === null)) return false;
                if (!slice.some(s => s !== null)) return false;
                const regularSymbols = slice.filter(s => s && s !== this.SPECIAL_SYMBOLS.WILD);
                return new Set(regularSymbols).size <= 1;
            }

            isLineDead(line) {
                for (let i = 0; i <= line.length - this.MIN_SEQUENCE_LENGTH; i++) {
                    const window = line.slice(i, i + this.MIN_SEQUENCE_LENGTH);
                    if (window.includes(this.SPECIAL_SYMBOLS.CURSED) || window.includes(this.SPECIAL_SYMBOLS.STUCK)) {
                        continue;
                    }
                    const actualSymbols = window.filter(s => s && s !== this.SPECIAL_SYMBOLS.WILD && s !== this.SPECIAL_SYMBOLS.CURSED);
                    if (new Set(actualSymbols).size <= 1) {
                        return false; 
                    }
                }
                return true;
            }

            checkGridBadges(stats) {
                let found3x3 = false;
                let found4x4 = false;

                for (let size = 4; size >= 3; size--) {
                    if ((size === 4 && found4x4) || (size === 3 && found3x3)) continue;

                    for (let r = 0; r <= this.GRID_SIZE - size; r++) {
                        for (let c = 0; c <= this.GRID_SIZE - size; c++) {
                            const first = this.gridData[r][c];
                            if (!first || first === this.SPECIAL_SYMBOLS.CURSED || first === this.SPECIAL_SYMBOLS.WILD) continue;
                            
                            let isSolidSquare = true;
                            for (let i = 0; i < size; i++) {
                                for (let j = 0; j < size; j++) {
                                    if (this.gridData[r + i][c + j] !== first) {
                                        isSolidSquare = false;
                                        break;
                                    }
                                }
                                if (!isSolidSquare) break;
                            }

                            if (isSolidSquare) {
                                if (size === 4) found4x4 = true;
                                if (size === 3) found3x3 = true;
                            }
                        }
                    }
                }
                if (found4x4) unlockBadge('fineSquare', stats);
                if (found3x3) unlockBadge('fineNine', stats);
            }

            calculateBonusGrids() {
                let points = 0;
                for (let size = this.GRID_SIZE; size >= 2; size--) {
                    for (let r = 0; r <= this.GRID_SIZE - size; r++) {
                        for (let c = 0; c <= this.GRID_SIZE - size; c++) {
                            const first = this.gridData[r][c];
                            if (!first || first === this.SPECIAL_SYMBOLS.CURSED) continue;
                            const subgrid = Array(size).fill(0).map((_, i) => this.gridData[r+i].slice(c, c + size));
                            const flatSubgrid = subgrid.flat();
                            if (flatSubgrid.some(cell => !cell || cell === this.SPECIAL_SYMBOLS.CURSED)) continue;
                            const regularSymbols = flatSubgrid.filter(s => s !== this.SPECIAL_SYMBOLS.WILD);
                            if (new Set(regularSymbols).size <= 1) {
                                points += size * size;
                            }
                        }
                    }
                }
                return points;
            }
            
            saveStateForUndo() { this.lastGameState = this.getState(); }
            
            async completeMove(r, c) {
                this.gameStateManager.setState('PROCESSING_TURN');
                const firstCellCoords = this.firstPlacementCell; 
                this.gridData[r][c] = this.currentRoll[1];
                this.lastMoveCoords = [{r,c}, firstCellCoords];
                this.firstPlacementCell = null;
                this.turnCount++;
                this.renderer.updateProgressBar();
                this.renderer.updateGridCell(r, c);
                this.audioManager.play('pop');
                this.triggerVibration(20);

                this.vibratedForScoreThisTurn = false;

                const placedSymbols = [this.gridData[r][c], this.gridData[firstCellCoords.r][firstCellCoords.c]];
                if (placedSymbols.includes(this.SPECIAL_SYMBOLS.WILD)) {
                    createSparkles(this.renderer.gridCells[r][c]);
                    createSparkles(this.renderer.gridCells[firstCellCoords.r][firstCellCoords.c]);
                }
                if (placedSymbols.includes(this.SPECIAL_SYMBOLS.CURSED)) {
                    const cursedCell = this.gridData[r][c] === this.SPECIAL_SYMBOLS.CURSED ? this.renderer.gridCells[r][c] : this.renderer.gridCells[firstCellCoords.r][firstCellCoords.c];
                    this.renderer.showCurseEffect(cursedCell);
                    this.triggerVibration([100, 50, 100]);
                }
                
                await delay(CONSTANTS.MOVE_COMPLETION_DELAY);
                this.processTurnEnd();
            }

            processTurnEnd() {
                if (this.gameStateManager.is('GAME_OVER')) return;
                this.updateAllScores(); 
                if (this.turnCount >= this.MAX_TURNS || !this.hasValidMoves()) {
                    this.gameStateManager.setState('AWAITING_ROLL');
                    this.renderer.renderControls();
                    return;
                }
                this.gameStateManager.setState('AWAITING_ROLL');
                this.renderer.renderControls();
            }
            
            async waitForCellClick(validCells) {
                const board = this.DOMElements.game_board;
                let clickHandler;
                try {
                    return await new Promise(resolve => {
                        clickHandler = (e) => {
                            const cellEl = e.target.closest('[data-row]');
                            if (!cellEl) return;
                            const r = parseInt(cellEl.dataset.row);
                            const c = parseInt(cellEl.dataset.col);

                            if (validCells.some(cell => cell.r === r && cell.c === c)) {
                                resolve({ r, c });
                            }
                        };
                        board.addEventListener('click', clickHandler);
                    });
                } finally {
                    if (clickHandler) {
                        board.removeEventListener('click', clickHandler);
                    }
                }
            }

            async startGoldenAllohaSequence() {
                this.gameStateManager.setState('AWAITING_GOLDEN_PLACEMENT');

                const emptyCells = [];
                for (let r = 0; r < this.GRID_SIZE; r++) {
                    for (let c = 0; c < this.GRID_SIZE; c++) {
                        if (!this.gridData[r][c]) emptyCells.push({ r, c });
                    }
                }

                if (emptyCells.length === 0) {
                    this.endGame("Grid is full!");
                    return;
                }
                
                const chosenSymbol = await this.renderer.renderGoldenAllohaSelector();
                this.renderer.renderGoldenAllohaPlacementPrompt(chosenSymbol);
                
                emptyCells.forEach(({ r, c }) => {
                    if (this.renderer.gridCells[r] && this.renderer.gridCells[r][c]) {
                        this.renderer.gridCells[r][c].classList.add('golden-placement-option');
                    }
                });
                
                const targetCell = await this.waitForCellClick(emptyCells);
                
                emptyCells.forEach(({ r, c }) => {
                    if (this.renderer.gridCells[r] && this.renderer.gridCells[r][c]) {
                        this.renderer.gridCells[r][c].classList.remove('golden-placement-option');
                    }
                });

                this.gridData[targetCell.r][targetCell.c] = chosenSymbol;
                this.renderer.updateGridCell(targetCell.r, targetCell.c);
                createSparkles(this.renderer.gridCells[targetCell.r][targetCell.c]);
                this.audioManager.play('chime');
                this.triggerVibration(50);

                emptyCells.forEach(({ r, c }) => {
                    if (r !== targetCell.r || c !== targetCell.c) {
                        this.stuckBlocks.add(`${r},${c}`);
                        this.gridData[r][c] = this.SPECIAL_SYMBOLS.STUCK;
                        this.renderer.updateGridCell(r, c);
                    }
                });

                if (emptyCells.length > 1) this.audioManager.play('thud');

                await delay(CONSTANTS.GOLDEN_ALLOHA_DELAY); 

                this.endGame("The grid is complete!");
            }
            
            checkEndGameBadges() {
                let stats = getPlayerStats();
                
                stats.gamesPlayed++;
                if (this.isTimeBurst && this.currentTotalScore > 0) stats.timeBurstWins++;
                if (!this.isTimeBurst && this.currentTotalScore > 0) stats.classicWins++;
                stats.playedEditions[this.config.id] = true;

                const today = new Date().toISOString().slice(0, 10);
                const lastPlayed = stats.lastPlayed || '';
                const yesterday = new Date(Date.now() - 86400000).toISOString().slice(0, 10);
                
                if (this.currentTotalScore > 0) {
                    // Only winning games count toward streak
                    if (lastPlayed === yesterday) {
                        // Played yesterday and won - continue streak
                        stats.streak = (stats.streak || 0) + 1;
                    } else if (lastPlayed === today) {
                        // Already played today - don't change streak
                    } else {
                        // First play today, but didn't play yesterday - start new streak
                        stats.streak = 1;
                    }
                } else {
                    // Lost game - don't break streak, just don't increment it
                    // Players can still maintain streak by winning later today
                }
                
                // Always update last played date
                stats.lastPlayed = today;

                if (stats.gamesPlayed >= 1) unlockBadge('baby', stats);
                if (stats.gamesPlayed >= 10) unlockBadge('enthusiast', stats);
                if (stats.gamesPlayed >= 50) unlockBadge('veteran', stats);

                if (stats.streak >= 3) unlockBadge('onFire', stats);
                if (stats.streak >= 7) unlockBadge('unstoppable', stats);
                if (stats.streak >= 30) unlockBadge('legendary', stats);

                if (stats.timeBurstWins >= 10) unlockBadge('masterOfTime', stats);

                if (this.currentTotalScore > 100) unlockBadge('centuryClub', stats);
                if (this.gridData.flat().every(cell => cell !== null)) unlockBadge('gridMaster', stats);
                if (this.usedSuperpowers.size === 0 && this.currentTotalScore > 0) unlockBadge('pureSkill', stats);
                if (this.scores.hero === 14) unlockBadge('heroWorship', stats);

                if (Object.keys(stats.playedEditions).length >= 5) unlockBadge('explorer', stats);
                if (Object.keys(stats.playedEditions).length === Object.keys(this.allVariantConfigs).length) unlockBadge('collector', stats);
                if (stats.classicWins > 0 && stats.timeBurstWins > 0) unlockBadge('allRounder', stats);
                
                this.checkGridBadges(stats);
                const saved = savePlayerStats(stats);
                if (!saved) {
                    console.warn('Game stats could not be saved. Progress may be lost.');
                }
            }

            endGame(reason = "") {
                if (this.gameStateManager.is('GAME_OVER')) return;
                this.stopTimer();
                this.gameStateManager.setState('GAME_OVER');
                this.lastMoveCoords = null;
                this.updateAllScores();

                this.checkEndGameBadges();

                if (reason === "Time's up!") {
                    this.DOMElements.game_board_container.classList.add('shake-animation');
                    setTimeout(() => this.DOMElements.game_board_container.classList.remove('shake-animation'), 500);
                }
                
                let finalScore = this.currentTotalScore;
                
                const currentEditionId = this.config.id;
                const unlockRule = unlockProgression[currentEditionId];

                if (unlockRule && finalScore >= unlockRule.score) {
                    gameManager.unlockEdition(unlockRule.unlocks);
                }
                
                const isGridIncomplete = this.gridData.flat().includes(null);
                if (reason === "Time's up!" && isGridIncomplete) {
                    finalScore = 0;
                }

                this.renderer.renderEndGamePanel(finalScore);

                if (this.scores.penalty < 0) {
                    this.triggerVibration([150, 50, 70]);
                }

                const highScoreKey = `cactiFactiHighScore_${this.config.id}_${this.isTimeBurst ? 'timeburst' : 'classic'}`;
                const currentHighScore = parseInt(localStorage.getItem(highScoreKey)) || 0;
                if (finalScore > currentHighScore) {
                    localStorage.setItem(highScoreKey, finalScore);
                    this.highScore = finalScore;
                    this.renderer.triggerConfetti();
                }

                this.DOMElements.game_over_reason.textContent = reason;
                animateScoreUpdate('final-score-modal', finalScore, 3);
                animateScoreUpdate('high-score-modal', this.highScore, 3);

                // Show streak if player won
                const stats = getPlayerStats();
                const currentStreak = stats.streak || 0;
                if (finalScore > 0 && currentStreak > 1) {
                    const streakText = currentStreak >= 3 
                        ? `🔥 ${currentStreak} Day Streak! 🔥` 
                        : `${currentStreak} Day Streak`;
                    this.DOMElements.game_over_reason.textContent = streakText;
                }
                
                const formatNegative = (val, len = 2) => val < 0 ? `(${String(Math.abs(val)).padStart(len,'0')})` : String(val).padStart(len,'0');
                this.DOMElements.final_rows_score.textContent = formatNegative(this.scores.rows);
                this.DOMElements.final_cols_score.textContent = formatNegative(this.scores.cols);
                this.DOMElements.final_cross_score.textContent = formatNegative(this.scores.cross);
                this.DOMElements.final_bonus_score.textContent = formatNegative(this.scores.bonus);
                this.DOMElements.final_hero_score.textContent = formatNegative(this.scores.hero);
                this.DOMElements.final_penalty_score.textContent = formatNegative(this.scores.penalty);

                setTimeout(() => {
                    handleModalOpen(this.DOMElements.game_over_modal);
                }, CONSTANTS.END_GAME_MODAL_DELAY);
            }

            async handleShareScore(score, highScore) {
                const shareBtn = this.DOMElements.share_score_btn;
                const shareBtnSpan = shareBtn.querySelector('span');
                if (!shareBtn || !shareBtnSpan) return;

                const originalBtnText = shareBtnSpan.textContent;
                const modalContent = this.DOMElements.modal_content_game_over;

                try {
                    shareBtnSpan.textContent = 'Generating...';
                    shareBtn.disabled = true;

                    await new Promise(resolve => setTimeout(resolve, 50));

                    const canvas = await html2canvas(modalContent, {
                        allowTaint: true,
                        useCORS: true,
                        backgroundColor: null,
                        ignoreElements: (element) => element.classList.contains('no-screenshot')
                    });

                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    if (!blob) throw new Error("Canvas to Blob conversion failed.");
                    
                    const file = new File([blob], 'alloha-score.png', { type: 'image/png' });
                    const shareText = `✨ I scored ${score} in Alloha! ✨\n\nThink you can beat my score in Alloha? 🎲\n\nPlay now: https://abhimanyulodha.github.io/alloha/`;

                    if (navigator.share && navigator.canShare({ files: [file] })) {
                        await navigator.share({
                            title: 'My Alloha Score!',
                            text: shareText,
                            files: [file]
                        });
                    } else {
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = 'Alloha-Score.png';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                    }
                } catch (error) {
                    console.error('Sharing failed:', error);
                    shareBtnSpan.textContent = 'Error!';
                } finally {
                    setTimeout(() => {
                        shareBtnSpan.textContent = originalBtnText;
                        shareBtn.disabled = false;
                    }, 2000);
                }
            }

            hasValidMoves() { for (let r = 0; r < this.GRID_SIZE; r++) for (let c = 0; c < this.GRID_SIZE; c++) if (!this.gridData[r][c]) { const n = [[-1, 0], [1, 0], [0, -1], [0, 1]]; for (const [dr, dc] of n) { const nr = r + dr, nc = c + dc; if (nr >= 0 && nr < this.GRID_SIZE && nc >= 0 && nc < this.GRID_SIZE && !this.gridData[nr][nc]) return true; } } return false; }
            detectStuckBlocks() { this.stuckBlocks.clear(); for (let r = 0; r < this.GRID_SIZE; r++) for (let c = 0; c < this.GRID_SIZE; c++) if (!this.gridData[r][c]) { const n = [[-1, 0], [1, 0], [0, -1], [0, 1]]; if (n.every(([dr, dc]) => { const nr = r + dr, nc = c + dc; return nr < 0 || nr >= this.GRID_SIZE || nc < 0 || nc >= this.GRID_SIZE || this.gridData[nr][nc] })) this.stuckBlocks.add(`${r},${c}`); } this.renderer.updateFullGrid(); }
            updateAllScores() {
                const rS = this.calculateRowScores(), cS = this.calculateColumnScores(), crS = this.calculateCrossScore(), bS = this.calculateBonusGrids(), hS = this.calculateHeroBonus();
                
                this.renderer.triggerBoardAndFloatAnimations(rS.lines, this.lastMoveCoords);
                this.renderer.triggerBoardAndFloatAnimations(cS.lines, this.lastMoveCoords);
                
                this.scores = { rows: rS.total, cols: cS.total, cross: crS, bonus: bS, hero: hS, penalty: -this.stuckBlocks.size };
                this.currentTotalScore = rS.total + cS.total + crS + bS + hS - this.stuckBlocks.size;

                this.renderer.updateScoreDisplays(this.scores.rows, this.scores.cols, this.scores.cross, this.scores.bonus, this.scores.hero, this.scores.penalty);
                this.renderer.updateIndividualScores(rS.individual, cS.individual);
            }

            calculateHeroBonus() {
                let heroScore = 0;
                if(this.lastMoveCoords) {
                    this.lastMoveCoords.forEach(coord => {
                        if (this.heroBlocks.has(`${coord.r},${coord.c}`) && this.gridData[coord.r][coord.c] === this.heroSymbol) {
                            heroScore += 2;
                            this.heroBlocks.delete(`${coord.r},${coord.c}`);
                            showFloatingScore('+2', this.renderer.gridCells[coord.r][coord.c]);
                            createSparkles(this.renderer.gridCells[coord.r][coord.c]);
                        }
                    });
                }
                return this.scores.hero + heroScore;
            }

            calculateRowScores() { 
                let total = 0, individual = [], allScoredLines = [];
                for (let i = 0; i < this.GRID_SIZE; i++) {
                    const result = this.calculateLineScore(this.gridData[i], 'row', i);
                    individual.push(result.total);
                    total += result.total;
                    allScoredLines.push(...result.lines);
                }
                return { total, individual, lines: allScoredLines };
            }
            calculateColumnScores() {
                let total = 0, individual = [], allScoredLines = [];
                for (let i = 0; i < this.GRID_SIZE; i++) {
                    const col = this.gridData.map(row => row[i]);
                    const result = this.calculateLineScore(col, 'col', i);
                    individual.push(result.total);
                    total += result.total;
                    allScoredLines.push(...result.lines);
                }
                return { total, individual, lines: allScoredLines };
            }

            calculateCrossScore() {
                let bonusScore = 0;
                const getScoreForSegment = (segmentSymbols) => {
                    if (segmentSymbols.length < this.MIN_SEQUENCE_LENGTH) return 0;
                    let score = 0; const usedIndices = new Set();
                    for (let len = segmentSymbols.length; len >= this.MIN_SEQUENCE_LENGTH; len--) {
                         for (let i = 0; i <= segmentSymbols.length - len; i++) {
                            if ([...Array(len).keys()].some(k => usedIndices.has(i + k))) continue;
                            const slice = segmentSymbols.slice(i, i + len);
                            if (this.isValidSequence(slice)) {
                                score += this.SCORING_RULES[len] || 0;
                                for (let k = 0; k < len; k++) if (slice[k] !== this.SPECIAL_SYMBOLS.WILD) usedIndices.add(i + k);
                            }
                        }
                    }
                    if (score > 0) return score;
                    if (this.isLineDead(segmentSymbols)) return this.CROSS_DEATH_PENALTY;
                    return 0;
                };

                (this.config.getCrossScoreSegments() || []).forEach(seg => {
                    const segmentSymbols = [];
                    for (let i = seg.start; i <= seg.end; i++) {
                        segmentSymbols.push(seg.type === 'row' ? this.gridData[seg.index][i] : this.gridData[i][seg.index]);
                    }
                    bonusScore += getScoreForSegment(segmentSymbols);
                });

                // Use config instead of hardcoded variant check
                if (this.config.hasSpecialDiagonal && this.config.getSpecialDiagonalCells) {
                    const diagonal = this.config.getSpecialDiagonalCells().map(
                        ({r, c}) => this.gridData[r][c]
                    );
                    bonusScore += getScoreForSegment(diagonal);
                }

                return bonusScore;
            }
            
            handleSymbolExchange(newSymbol) {
                if (!this.cellToExchange) return;
                const {r, c} = this.cellToExchange; this.gridData[r][c] = newSymbol;
                handleModalClose(this.DOMElements.exchange_modal);
                this.cellToExchange = null;
                this.consumeSuperpower(SUPERPOWERS.NO_RETURN); this.gameStateManager.setState('AWAITING_ROLL'); this.renderer.renderControls();
            }
            consumeSuperpower(powerName) {
                this.triggerVibration(30);
                this.audioManager.play('power-use'); this.usedSuperpowers.add(powerName); this.activeSuperpower = null;
                this.renderer.updateFullGrid(); this.updateAllScores(); this.renderer.updateSuperpowerButtonsUI();
            }
        }
        
        // --- GAME MANAGER ---
        const gameManager = {
            gameStates: {},
            activeVariantId: null,
            currentGameInstance: null,
            pendingAction: null,
            activeMode: 'classic',
            isAudioUnlocked: false,
            globalListenersAttached: false,

            unlockAudioContext() {
                if (this.isAudioUnlocked || !this.currentGameInstance) return;
                this.currentGameInstance.audioManager.unlock(this.currentGameInstance.DOMElements.audio_unlocker);
                this.isAudioUnlocked = true;
            },

            init() {
                this.switchVariant('plain_jean', false);
            },

            populateEditionModal() {
                const container = this.currentGameInstance ? this.currentGameInstance.DOMElements.edition_options : document.getElementById('edition-options');
                if (!container) return;
                container.innerHTML = '';

                // Get player stats to see what's unlocked
                const stats = getPlayerStats();
                const unlockedEditions = stats.unlockedEditions || {};

                // The first edition is always unlocked
                const isEditionUnlocked = (id) => id === 'plain_jean' || unlockedEditions[id] || DEV_UNLOCK_ALL;

                Object.values(variantConfigs).forEach(config => {
                    const button = document.createElement('button');
                    const unlocked = isEditionUnlocked(config.id);

                    button.className = 'w-full text-left p-3 rounded-lg font-semibold flex justify-between items-center transition-colors';
                    button.dataset.editionId = config.id;
                    
                    if (unlocked) {
                        button.innerHTML = `<span>${config.name}</span>`;
                        button.classList.add('hover:bg-gray-200/50');
                        button.onclick = () => {
                            const game = this.currentGameInstance;
                            const elements = game.DOMElements;
                            const isGameInProgress = game && game.turnCount > 0 && !game.gameStateManager.is('GAME_OVER');
                            
                            handleModalClose(elements.edition_select_modal);
                            const isTimeBurst = this.activeMode === 'timeburst';

                            if (isGameInProgress && config.id !== this.activeVariantId) {
                                this.pendingAction = () => this.switchVariant(config.id, isTimeBurst, true);
                                handleModalOpen(elements.confirm_restart_modal);
                            } else {
                                this.switchVariant(config.id, isTimeBurst);
                            }
                        };
                    } else {
                        // This is a locked edition
                        const unlockRule = Object.values(unlockProgression).find(rule => rule && rule.unlocks === config.id);
                        const scoreNeeded = unlockRule ? unlockRule.score : '';
                        const gameToPlay = Object.keys(unlockProgression).find(key => unlockProgression[key] && unlockProgression[key].unlocks === config.id);
                        const gameNameToPlay = variantConfigs[gameToPlay]?.name || '';

                        button.innerHTML = `
                            <div class="flex flex-col">
                                <span>${config.name}</span>
                                <span class="text-xs font-normal opacity-70">Score ${scoreNeeded} in ${gameNameToPlay} to unlock</span>
                            </div>
                            <span class="text-xl">🔒</span>`;
                        button.disabled = true;
                        button.classList.add('opacity-50', 'cursor-not-allowed');
                    }
                    container.appendChild(button);
                });
            },

            switchVariant(variantId, isTimeBurst, isNewGame = false) {
                if (this.currentGameInstance) {
                    this.currentGameInstance.stopTimer();
                    this.currentGameInstance.inputHandler.detachAllListeners();
                }
                const gameContainer = document.getElementById('game-container');
                gameContainer.style.transition = 'opacity 0.25s ease-in-out';
                gameContainer.style.opacity = '0';

                if (this.currentGameInstance && !isNewGame) {
                    this.gameStates[this.activeVariantId + (this.currentGameInstance.isTimeBurst ? '_timeburst' : '_classic')] = this.currentGameInstance.getState();
                }

                setTimeout(() => {
                    this.activeVariantId = variantId;
                    const variantConfig = variantConfigs[variantId];
                    const themeConfig = themeConfigs[variantConfig.themeId];
                    applyTheme(variantConfig.themeId);

                    const gameStateKey = variantId + (isTimeBurst ? '_timeburst' : '_classic');
                    const savedState = isNewGame ? null : this.gameStates[gameStateKey];
                    
                    if (isNewGame) {
                        delete this.gameStates[gameStateKey];
                    }

                    this.currentGameInstance = new Game(variantConfig, themeConfig, isTimeBurst, variantConfigs, savedState);
                    this.populateEditionModal();
                    this.setupGlobalEventListeners();
                    
                    gameContainer.style.opacity = '1';
                }, CONSTANTS.VARIANT_SWITCH_DELAY);
            },
            
            resetCurrentVariant() {
                if (this.currentGameInstance) {
                    this.currentGameInstance.stopTimer();
                }
                this.switchVariant(this.activeVariantId, this.currentGameInstance.isTimeBurst, true);
            },
            
            unlockEdition(editionId) {
                let stats = getPlayerStats();
                if (!stats.unlockedEditions) {
                    stats.unlockedEditions = {};
                }
                if (stats.unlockedEditions[editionId]) {
                    return; // Already unlocked
                }

                stats.unlockedEditions[editionId] = true;
                savePlayerStats(stats);

                const unlockedEditionName = variantConfigs[editionId]?.name || 'a new edition';
                const unlockedEditionNameEl = this.currentGameInstance.DOMElements.unlocked_edition_name;
                
                if (unlockedEditionNameEl) {
                    unlockedEditionNameEl.textContent = unlockedEditionName;
                }

                handleModalOpen(this.currentGameInstance.DOMElements.unlock_modal);
                
                // Refresh the modal content to show the newly unlocked game
                this.populateEditionModal();
            },

            setupGlobalEventListeners() {
                // This function runs after the first game instance is created.
                // We can now safely access the DOMElements from it.
                if (this.globalListenersAttached) return;
                this.globalListenersAttached = true;
                const elements = this.currentGameInstance.DOMElements;

                // Centralized Modal Close Button Logic
                const modalClosers = [
                    [elements.close_rules_btn, elements.rules_modal],
                    [elements.close_edition_select_btn, elements.edition_select_modal],
                    [elements.close_game_over_btn, elements.game_over_modal],
                    [elements.close_tutorial_btn, elements.tutorial_modal],
                    [elements.close_warning_btn, elements.warning_modal],
                    [elements.close_warning_x_btn, elements.warning_modal],
                    [elements.close_unlock_btn, elements.unlock_modal],
                    [elements.close_unlock_x_btn, elements.unlock_modal],
                    [elements.close_badges_btn, elements.badges_modal],
                ];

                modalClosers.forEach(([button, modal]) => {
                    if (button && modal) {
                        button.addEventListener('click', () => handleModalClose(modal));
                    }
                });

                elements.tutorial_next_btn.addEventListener('click', () => {
                    if (gameManager.currentGameInstance) {
                        gameManager.currentGameInstance.tutorialStep++;
                        gameManager.currentGameInstance.showTutorialStep();
                    }
                });

                elements.close_post_game_modal_btn.addEventListener('click', () => {
                    handleModalClose(elements.post_game_modal);
                });

                elements.post_game_play_again_btn.addEventListener('click', () => {
                    handleModalClose(elements.post_game_modal);
                    this.resetCurrentVariant();
                });

                elements.post_game_select_edition_btn.addEventListener('click', () => {
                    handleModalClose(elements.post_game_modal);
                    elements.select_edition_btn.click(); // Re-use existing logic
                });

                // Other Global Listeners
                elements.select_edition_btn.addEventListener('click', () => {
                    const isTimeBurst = this.currentGameInstance.isTimeBurst;
                    this.activeMode = isTimeBurst ? 'timeburst' : 'classic';
                    this.unlockAudioContext();
                    
                    if(isTimeBurst) {
                        elements.mode_toggle_switch.classList.add('time-burst-active');
                        elements.time_burst_text.style.color = 'var(--accent)';
                        elements.classic_text.style.color = 'var(--text-secondary)';
                    } else {
                        elements.mode_toggle_switch.classList.remove('time-burst-active');
                        elements.classic_text.style.color = 'var(--text)';
                        elements.time_burst_text.style.color = 'var(--text-secondary)';
                    }

                    const currentEditionId = this.currentGameInstance.config.id;
                    document.querySelectorAll('#edition-options button').forEach(btn => {
                        btn.classList.remove('edition-selected');
                        if (btn.dataset.editionId === currentEditionId) {
                            btn.classList.add('edition-selected');
                        }
                    });

                    handleModalOpen(elements.edition_select_modal);
                });
                
                elements.play_again_btn.addEventListener('click', () => { 
                    handleModalClose(elements.game_over_modal);
                    this.resetCurrentVariant();
                });

                elements.change_edition_btn_modal.addEventListener('click', () => {
                    handleModalClose(elements.game_over_modal);
                    elements.select_edition_btn.click();
                });

                elements.share_score_btn.addEventListener('click', () => {
                    const game = this.currentGameInstance;
                    game.handleShareScore(game.currentTotalScore, game.highScore);
                });

                elements.badges_btn.addEventListener('click', () => {
                    renderBadgesGrid(elements);
                    // Show current streak
                    const stats = getPlayerStats();
                    const currentStreak = stats.streak || 0;
                    const infoText = elements.badge_info_text;
                    if (infoText && currentStreak > 0) {
                        const fireEmojis = '🔥'.repeat(Math.min(currentStreak, 10));
                        infoText.innerHTML = `Current Win Streak: <strong>${currentStreak} day${currentStreak > 1 ? 's' : ''}</strong> ${fireEmojis}`;
                    }
                    handleModalOpen(elements.badges_modal);
                });

                elements.share_badges_btn.addEventListener('click', () => {
                    handleShareBadges(elements.share_badges_btn, elements.modal_content_badges);
                });
                
                elements.mode_toggle_switch.addEventListener('click', () => {
                    elements.mode_toggle_switch.classList.toggle('time-burst-active');
                    this.activeMode = elements.mode_toggle_switch.classList.contains('time-burst-active') ? 'timeburst' : 'classic';
                    if (this.activeMode === 'timeburst') {
                        elements.time_burst_text.style.color = 'var(--accent)';
                        elements.classic_text.style.color = 'var(--text-secondary)';
                    } else {
                        elements.classic_text.style.color = 'var(--text)';
                        elements.time_burst_text.style.color = 'var(--text-secondary)';
                    }
                });
                
                elements.rules_btn.addEventListener('click', () => { handleModalOpen(elements.rules_modal); });

                elements.new_game_btn.addEventListener('click', () => {
                    const game = this.currentGameInstance;
                    if (game && game.gameStateManager.is('GAME_OVER')) {
                        this.resetCurrentVariant();
                        return;
                    }
                    if (game && game.turnCount > 0) {
                        this.pendingAction = () => this.resetCurrentVariant();
                        handleModalOpen(elements.confirm_restart_modal);
                    } else {
                        this.resetCurrentVariant();
                    }
                    this.unlockAudioContext();
                });

                elements.confirm_cancel_btn.addEventListener('click', () => {
                    this.pendingAction = null;
                    handleModalClose(elements.confirm_restart_modal);
                });
                
                elements.confirm_restart_btn.addEventListener('click', () => {
                    if (typeof this.pendingAction === 'function') {
                        this.pendingAction();
                    }
                    this.pendingAction = null;
                    handleModalClose(elements.confirm_restart_modal);
                });

                document.addEventListener('keydown', (e) => {
                    const game = this.currentGameInstance;
                    if (!game) return;
                    const elements = game.DOMElements;

                    if (e.key === 'Escape') {
                        if (game.activeSuperpower) {
                             if (game.activeSuperpower === SUPERPOWERS.SWAP_THEM && game.swapFirstCell) {
                                game.renderer.gridCells[game.swapFirstCell.r][game.swapFirstCell.c].classList.remove('pulse-animation');
                                game.swapFirstCell = null;
                            }
                            game.activeSuperpower = null;
                            game.renderer.updateSuperpowerButtonsUI();
                            game.gameStateManager.setState(game.firstPlacementCell ? 'AWAITING_PLACEMENT' : 'AWAITING_ROLL');
                        } else {
                           Object.values(elements.modals).forEach(modal => {
                                if (modal?.classList.contains('is-open')) {
                                   handleModalClose(modal);
                                }
                           });
                        }
                    }
                    if (e.key === ' ' && game.gameStateManager.is('AWAITING_ROLL')) {
                        e.preventDefault();
                        const rollBtn = elements.roll_dice_btn;
                        if (rollBtn) rollBtn.click();
                    }
                });
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            gameManager.init();
        });
    })();
    </script>
</body>
</html>
