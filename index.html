<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alloha</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&family=Quicksand:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: linear-gradient(135deg, #FDFCFB 0%, #E2D1C3 100%);
            --card: rgba(255, 255, 255, 0.85);
            --text: #5D4037;
            --text-secondary: #8D6E63;
            --accent: #E57373;
            --accent-light: rgba(229, 115, 115, 0.1);
            --accent-gradient: linear-gradient(135deg, #E57373 0%, #FF8A65 100%);
            --accent-gradient-shaded: linear-gradient(135deg, #EE9A9A 0%, #FFCCBC 100%);
            --highlighted-bg: rgba(229, 115, 115, 0.15);
            --highlighted-border: rgba(229, 115, 115, 0.3);
            --grid-cell-bg: #FAF8F5;
            --toggle-bg-inactive: #E0E0E0;
            --stuck-block: linear-gradient(135deg, #757575 0%, #616161 100%);
            --glass-border: rgba(255, 255, 255, 0.2);
            --faint-border: rgba(0, 0, 0, 0.08);
            --shadow-soft: 0 4px 15px rgba(0, 0, 0, 0.05);
            --shadow-medium: 0 8px 30px rgba(0, 0, 0, 0.07);
            --shadow-strong: 0 15px 50px rgba(0, 0, 0, 0.09);
            --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
            --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
            --ease-quick: cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        @keyframes gradient-pan {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        body {
            font-family: 'Quicksand', sans-serif;
            font-weight: 500;
            background: var(--bg);
            color: var(--text);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: background 0.3s ease-in-out;
            background-size: 400% 400%;
            animation: gradient-pan 20s ease infinite;
        }
        body.modal-open {
            overflow: hidden;
        }
        .themed-button {
            font-weight: 600; border-radius: 12px; transition: all 0.3s var(--ease-smooth);
            border: none; position: relative; overflow: hidden; transform-origin: center;
        }
        .themed-button:hover { transform: translateY(-2px); box-shadow: var(--shadow-medium); }
        .themed-button:active { transform: scale(0.98); transition-duration: 0.1s; }
        
        .glass-card {
            background: var(--card);
            backdrop-filter: blur(20px) saturate(180%); -webkit-backdrop-filter: blur(20px) saturate(180%);
            box-shadow: var(--shadow-soft), 0 0 0 1px var(--glass-border), inset 0 1px 0 rgba(255, 255, 255, 0.3); border: none !important; transition: all 0.3s var(--ease-smooth); position: relative; overflow: hidden;
        }
        .enhanced-shadow {
            box-shadow: var(--shadow-medium), 0 0 0 1px var(--glass-border), inset 0 1px 0 rgba(255, 255, 255, 0.3) !important;
        }
        .grid-cell {
            aspect-ratio: 1; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: clamp(1.2rem, 5.5vw, 2.75rem);
            transition: all 0.3s var(--ease-smooth); background: var(--grid-cell-bg);
            border: 1px solid rgba(0, 0, 0, 0.04);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.02);
            position: relative; overflow: hidden; min-width: 40px; min-height: 40px;
        }
        .grid-cell:hover:not(.highlighted):not(.stuck-cell):not(.score-display-cell) {
            transform: scale(1.03);
            box-shadow: 0 0 12px rgba(0,0,0,0.1);
            z-index: 2;
        }
        .themed-modal { border-radius: 20px; background: var(--card); box-shadow: var(--shadow-strong); backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px); }
        
        #new-game-btn, #confirm-restart-btn, #play-again-btn, #close-warning-btn { background: var(--accent-gradient); }
        #select-edition-btn { background: var(--accent-gradient-shaded); }

        .progress-bar-container { position: relative; overflow: hidden; background: var(--accent-light); border-radius: 9999px; }
        .progress-bar-fill { background: var(--accent-gradient); position: relative; overflow: hidden; transition: width 0.3s var(--ease-smooth); height: 100%; }
        .progress-bar-fill::after { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.6) 50%, transparent 100%); animation: progress-shimmer 2s infinite; }
        @keyframes progress-shimmer { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }

        @keyframes dice-tumble {
            0%   { transform: rotate(0deg) scale(1); filter: blur(0px); }
            25%  { transform: rotate(-90deg) scale(1.05); }
            50%  { transform: rotate(-180deg) scale(1.1); filter: blur(3px); }
            75%  { transform: rotate(-270deg) scale(1.05); }
            100% { transform: rotate(-360deg) scale(1); filter: blur(0px); }
        }
        .dice-tumble { animation: dice-tumble 0.6s var(--ease-bounce); }
        .shake-animation { animation: shake 0.4s ease-in-out; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-5px) rotate(-3deg); } 75% { transform: translateX(5px) rotate(3deg); } }

        .modal { transition: all 0.3s var(--ease-smooth); }
        .modal.is-open { opacity: 1; visibility: visible; }
        .modal-content { transition: all 0.3s var(--ease-smooth); }
        .modal.is-open .modal-content { transform: scale(1) translateY(0); }
        
        .superpower-btn { position: relative; background: transparent; border: none; box-shadow: none; color: var(--text-secondary); font-weight: 500; border-radius: 12px; padding: 4px; font-size: 0.7rem; text-align: center; transition: all 0.3s ease; cursor: pointer; min-width: 50px; line-height: 1.2; }
        .superpower-btn:hover:not(:disabled) { transform: translateY(-2px); text-decoration: underline; background: var(--accent-light); }
        .superpower-btn--active { font-weight: 700; transform: translateY(-2px) !important; background: var(--accent-light); }
        .superpower-btn:disabled { opacity: 0.5; cursor: not-allowed; text-decoration: none; }
        
        #close-rules-btn, #close-game-over-btn, #close-edition-select-btn, #confirm-cancel-btn { color: var(--text-secondary); }
        #close-rules-btn:hover, #close-game-over-btn:hover, #close-edition-select-btn:hover, #confirm-cancel-btn:hover { color: var(--text); background-color: var(--accent-light); }
        
        .score-display-cell { 
            background: var(--grid-cell-bg) !important; 
            color: var(--text-secondary);
            font-size: clamp(1rem, 4vw, 1.5rem);
        }
        .highlighted { 
            background-color: var(--highlighted-bg); 
            border: 1px solid var(--highlighted-border);
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.2); 
            animation: pulse-highlight 2s infinite; 
        }
        @keyframes pulse-highlight { 0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4); } 70% { box-shadow: 0 0 0 4px rgba(76, 175, 80, 0); } 100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); } }
        
        .alloha-logo { 
            width: 100%; height: 100%; display: flex; align-items: center; justify-content: center;
            animation: pulse-logo 4s infinite ease-in-out;
        }
        .alloha-logo svg { width: 100%; height: 100%; }
        .alloha-logo svg path, .alloha-logo svg g { fill: var(--accent) !important; }

        #mode-toggle-switch { transition: background-color 0.2s ease-in-out; background-color: var(--toggle-bg-inactive); }
        #mode-toggle-switch.time-burst-active { background-color: var(--accent); }
        #mode-toggle-switch.time-burst-active #mode-toggle-thumb { transform: translateX(1.5rem); }
        #timer-display { font-variant-numeric: tabular-nums; transform: translateZ(0); }
        
        #edition-options, #rules-modal .space-y-4 {
             -webkit-overflow-scrolling: touch;
        }
        #edition-options::-webkit-scrollbar { width: 8px; }
        #edition-options::-webkit-scrollbar-track { background: rgba(0,0,0,0.05); border-radius: 4px; }
        #edition-options::-webkit-scrollbar-thumb { background: rgba(0,0,0,0.2); border-radius: 4px; }
        #edition-options::-webkit-scrollbar-thumb:hover { background: rgba(0,0,0,0.3); }

        .edition-selected { background-color: var(--accent-light) !important; font-weight: 700; color: var(--accent); }

        @keyframes shimmer-text-anim {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }
        .shimmer-text {
            background: linear-gradient(90deg, var(--toggle-bg-inactive), white, var(--toggle-bg-inactive));
            background-size: 200% auto;
            color: transparent;
            background-clip: text;
            -webkit-background-clip: text;
            animation: shimmer-text-anim 2.5s linear infinite;
        }

        .confetti-piece {
            position: absolute; width: 8px; height: 16px; background: var(--accent); top: -20px;
            opacity: 0; animation-timing-function: linear;
        }
        @keyframes confetti-fall {
            0% { top: -20px; opacity: 1; transform: rotate(0deg); }
            100% { top: 100%; opacity: 1; transform: rotate(720deg); }
        }
        
        @keyframes pulse-faint {
            0%, 100% { transform: scale(1); box-shadow: var(--shadow-soft); }
            50% { transform: scale(1.02); box-shadow: var(--shadow-medium); }
        }
        #select-edition-btn { animation: pulse-faint 3s infinite ease-in-out; }
        @keyframes pulse-logo {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .stuck-cell {
            background-image: var(--stuck-block) !important;
            color: white; font-size: clamp(1rem, 4vw, 2rem) !important;
            text-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }
        .golden-placement-option {
            cursor: pointer; box-shadow: 0 0 0 4px gold, inset 0 0 10px gold;
            background-color: rgba(255, 215, 0, 0.2); animation: pulse-faint 1.5s infinite;
        }
        @keyframes bob-animation {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        .bob-animation { animation: bob-animation 2s ease-in-out infinite; }
        
        @keyframes twinning-flash {
            0%, 100% { background-color: var(--highlighted-bg); }
            50% { background-color: var(--accent); }
        }
        .twinning-flash-animation { animation: twinning-flash 1.5s ease-in-out; }

        .tutorial-progress-dot {
            width: 0.5rem; height: 0.5rem; border-radius: 9999px; background-color: var(--accent-light);
        }
        .tutorial-progress-dot.active {
            background-color: var(--accent);
        }

        .valid-placement { box-shadow: 0 0 0 1px rgba(229, 115, 115, 0.3) !important; transform: scale(1.02) !important; }

        @keyframes score-pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.5); }
            50% { transform: scale(1.1); box-shadow: 0 0 0 6px rgba(255, 215, 0, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }
        .score-pulse-animation {
            animation: score-pulse 0.8s ease-in-out; z-index: 10;
        }

        .floating-score {
            position: fixed;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            z-index: 100;
            pointer-events: none;
            animation: float-to-score 1.2s ease-in forwards;
        }
        @keyframes float-to-score {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-80px) scale(0.5); }
        }
        
        .digit-score-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .digit-container {
            height: 1em; 
            overflow: hidden;
            line-height: 1em;
        }
        .digit-strip {
            display: flex;
            flex-direction: column;
            transition: transform 0.6s cubic-bezier(0.65, 0, 0.35, 1);
        }
        .score-parenthesis {
            display: inline-block;
            font-weight: bold;
        }

        .sparkle {
            position: fixed;
            width: 8px;
            height: 8px;
            background: #FFD700;
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
            opacity: 0;
            animation: sparkle-anim 0.7s ease-out;
        }
        @keyframes sparkle-anim {
            0% { opacity: 1; transform: scale(0.5) translate(0, 0); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: scale(1.5) translate(var(--sparkle-x), var(--sparkle-y)); }
        }

        .hero-block-hint::before {
            content: var(--hero-symbol);
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5em;
            color: var(--text);
            opacity: 0.1;
            z-index: 0;
        }
    </style>
    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-62DV4PDJ4X"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-62DV4PDJ4X');
    </script>
</head>
<body class="p-2 lg:p-4">
    <audio id="audio-unlocker" src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=" preload="auto"></audio>
    <main id="game-container" class="w-full max-w-5xl mx-auto flex flex-col lg:flex-row gap-4 lg:gap-6 items-center lg:items-stretch pt-8 lg:pt-16">
        <div class="w-full lg:w-2/3 relative">
            <div id="effects-container" class="absolute inset-0 pointer-events-none z-10 overflow-hidden"></div>
            <div id="game-board-container" class="p-2 lg:p-6 h-full glass-card rounded-2xl">
                <div class="grid grid-cols-8 gap-1 lg:gap-3 h-full">
                    <div id="game-board" class="col-span-7 grid grid-cols-7 gap-1 lg:gap-2"></div>
                    <div id="row-scores-display" class="col-span-1 grid grid-rows-7 gap-1 lg:gap-2"></div>
                    <div id="col-scores-display" class="col-span-7 grid grid-cols-7 mt-1 lg:mt-0 gap-1 lg:gap-2"></div>
                    <div class="flex items-center justify-center">
                        <div class="alloha-logo">
                            <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 396.75 396.749985" preserveAspectRatio="xMidYMid meet"><defs><clipPath id="864cd2432c"><path d="M 40 0 L 355 0 L 355 396.5 L 40 396.5 Z M 40 0 "/></clipPath></defs><g clip-path="url(#864cd2432c)"><g transform="matrix(1, 0, 0, 1, 40, 0)"><g><g transform="matrix(1, 0, 0, 1, 1, 0)"><g><g fill-opacity="1"><g transform="translate(0.873977, 194.870819)"><g><path d="M 137.910156 0 L 137.910156 -174.546875 L 6.804688 -174.546875 L 6.804688 0 L 50.503906 0 L 50.503906 -48.675781 L 94.207031 -48.675781 L 94.207031 0 Z M 94.207031 -88.449219 L 50.503906 -88.449219 L 50.503906 -134.507812 L 94.207031 -134.507812 Z M 94.207031 -88.449219 "/></g></g></g></g><g transform="matrix(1, 0, 0, 1, 146, 116)"><g><g fill-opacity="1"><g transform="translate(1.206642, 267.950498)"><g><path d="M 137.910156 0 L 137.910156 -174.546875 L 6.804688 -174.546875 L 6.804688 0 Z M 94.207031 -39.777344 L 50.503906 -39.777344 L 50.503906 -134.507812 L 94.207031 -134.507812 Z M 94.207031 -39.777344 "/></g></g></g></g></g><g transform="matrix(1, 0, 0, 1, 148, 0)"><g><g fill-opacity="1"><g transform="translate(0.26582, 194.870819)"><g><path d="M 137.386719 0 L 137.386719 -39.777344 L 50.503906 -39.777344 L 50.503906 -174.546875 L 6.804688 -174.546875 L 6.804688 0 Z M 137.386719 0 "/></g></g></g></g></g><g transform="matrix(1, 0, 0, 1, -0.000000000000007105, 116)"><g><g fill-opacity="1"><g transform="translate(1.876102, 267.950498)"><g><path d="M 137.910156 0 L 137.910156 -174.546875 L 94.207031 -174.546875 L 94.207031 -107.03125 L 50.503906 -107.03125 L 50.503906 -174.546875 L 6.804688 -174.546875 L 6.804688 0 L 50.503906 0 L 50.503906 -68.5625 L 94.207031 -68.5625 L 94.207031 0 Z M 137.910156 0 "/></g></g></g></g></g><g transform="matrix(1, 0, 0, 1, 242, 20)"><g><path fill-rule="nonzero" d="M 43.164062 120.25 L 0.375 120.25 L 0.375 0.414062 L 43.164062 0.414062 Z M 43.164062 120.25 "/></g></g><g transform="matrix(1, 0, 0, 1, 213, 20)"><g><path fill-rule="nonzero" d="M 0.839844 43.222656 L 0.839844 0.4375 L 63.683594 0.4375 L 63.683594 43.222656 Z M 0.839844 43.222656 "/></g></g></g></g></g></g></svg>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="w-full lg:w-1/3">
            <div id="scoring-panel" class="relative flex-1 flex flex-col gap-y-4 p-4 lg:p-6 glass-card rounded-2xl">
                
                <div class="glass-card enhanced-shadow rounded-2xl p-4 flex flex-col flex-1 min-h-0">
                    <div id="controls-container" class="flex-1 min-h-0">
                        <div id="pre-game-content"></div>
                        <div id="in-game-content"></div>
                    </div>
                    <div class="relative w-full h-2.5 progress-bar-container mt-4 flex-shrink-0">
                        <div id="progress-bar-fill" class="progress-bar-fill"></div>
                    </div>
                </div>

                <div class="glass-card enhanced-shadow rounded-2xl p-4">
                    <div class="flex justify-center items-center gap-3">
                        <button id="rules-btn" class="flex-1 py-2 px-4 themed-button text-sm" style="color: var(--accent); background: var(--accent-light);">How to Play</button>
                        <button id="new-game-btn" class="flex-1 py-2 px-4 themed-button text-white text-sm">New Game</button>
                    </div>
                    <div class="text-center mt-3">
                        <button id="select-edition-btn" class="w-full py-2 px-4 themed-button text-white text-sm flex items-center justify-center gap-2">
                            Select Game Edition
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                        </button>
                    </div>
                </div>
                
                <div class="glass-card enhanced-shadow rounded-2xl p-4 mt-auto">
                    <div class="grid grid-cols-2 gap-4 text-center">
                        <div>
                            <h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">Total Score</h3>
                            <div id="total-score" class="text-3xl font-bold" style="color: var(--accent);"></div>
                        </div>
                        <div>
                            <h3 class="text-xs font-semibold uppercase tracking-wider mb-1" style="color: var(--text-secondary);">High Score</h3>
                            <div id="high-score" class="text-3xl font-bold" style="color: #FFC107;"></div>
                        </div>
                    </div>
                    
                    <hr class="border-t my-4" style="border-color: var(--faint-border);">

                    <div class="grid grid-cols-3 gap-y-3 text-center">
                        <div class="border-r" style="border-color: var(--faint-border);">
                            <h3 class="text-xs font-semibold uppercase tracking-wider" style="color: var(--text-secondary);">Rows</h3>
                            <div id="rows-total-score" class="text-lg font-bold"></div>
                        </div>
                        <div class="border-r" style="border-color: var(--faint-border);">
                            <h3 class="text-xs font-semibold uppercase tracking-wider" style="color: var(--text-secondary);">Columns</h3>
                            <div id="cols-total-score" class="text-lg font-bold"></div>
                        </div>
                        <div>
                            <h3 class="text-xs font-semibold uppercase tracking-wider" style="color: var(--text-secondary);">Twinning</h3>
                            <div id="cross-total-score" class="text-lg font-bold" style="color: #FFC107;"></div>
                        </div>
                        <div class="border-r pt-3 border-t" style="border-color: var(--faint-border);">
                            <h3 class="text-xs font-semibold uppercase tracking-wider leading-tight" style="color: var(--text-secondary);">Grid<br>Bonus</h3>
                            <div id="bonus-grid-score" class="text-lg font-bold" style="color: #FFC107;"></div>
                        </div>
                        <div class="border-r pt-3 border-t" style="border-color: var(--faint-border);">
                            <h3 class="text-xs font-semibold uppercase tracking-wider leading-tight" style="color: var(--text-secondary);">Hero<br>Bonus</h3>
                            <div id="hero-bonus-score" class="text-lg font-bold" style="color: #FFC107;"></div>
                        </div>
                        <div class="pt-3 border-t" style="border-color: var(--faint-border);">
                            <h3 class="text-xs font-semibold uppercase tracking-wider leading-tight" style="color: var(--text-secondary);">Empty<br>Block</h3>
                            <div id="empty-block-penalty" class="text-lg font-bold" style="color: var(--text);"></div>
                        </div>
                    </div>
                </div>

            </div>
            </div>
    </main>

    <div id="rules-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-lg themed-modal p-6 transform scale-95 -translate-y-4">
            <div class="flex justify-between items-start mb-4">
                <div class="flex-grow">
                    <h2 id="rules-title" class="text-3xl font-bold" style="font-family: 'Pacifico', cursive; color: var(--accent);">How to Play Alloha</h2>
                    <p class="text-sm mt-2 font-bold" style="color: var(--text-secondary);">A fun & simple game by Abhimanyu Lodha</p>
                </div>
                <button id="close-rules-btn" aria-label="Close How to Play" class="w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold flex-shrink-0">×</button>
            </div>
            <div class="space-y-4 text-sm max-h-[70vh] overflow-y-auto pr-2" style="color: var(--text-secondary)">
                <h3 class="font-bold text-lg" style="color: var(--accent);">🎯 The Goal</h3>
                <p>Fill the 7x7 grid by placing pairs of 'Allohas' to create lines and patterns of matching symbols. Score the most points before the grid is full!</p>
                
                <h3 class="font-bold text-lg" style="color: var(--accent);">🕹️ How to Play</h3>
                <ol class="list-decimal list-inside space-y-1">
                    <li><b>Roll the Dice:</b> Click the '🎲' button to get your two Allohas for the turn.</li>
                    <li><b>Place Your Pair:</b> Place both Allohas in any two empty, adjacent (but not diagonal) squares on the grid.</li>
                    <li><b>Explore Editions:</b> Use the "Select Game Edition" button to discover different versions of the game, each with a unique theme and a special "Twinning" scoring pattern!</li>
                </ol>

                <h3 class="font-bold text-lg" style="color: var(--accent);">👑 The Hero Symbol</h3>
                <p>At the start of each game, one symbol is chosen as the "Hero." You will see faint watermarks of this symbol on 7 random squares. Place the correct Hero Symbol on these squares to earn a <b>+2 Hero Bonus</b> each time!</p>
                
                <h3 class="font-bold text-lg" style="color: var(--accent);">✨ Superpowers</h3>
                <p>You can use <b>two different superpowers</b> once per game to get out of a tight spot!</p>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>Past Lives:</b> Undoes your most recent move (placing a pair of Allohas).</li>
                    <li><b>Bomb Bae:</b> Lets you clear a stuck block (💣) by filling it with a random Alloha.</li>
                    <li><b>No Return:</b> Exchange any Alloha on the grid for a new one of your choice from the symbol set.</li>
                    <li><b>Swap Them:</b> Swap the positions of any two adjacent Allohas. This must be used <b>before</b> you roll the dice.</li>
                </ul>
                
                <h3 class="font-bold text-lg" style="color: var(--accent);">🎲 Special Blocks</h3>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>Wild Card (💎):</b> A powerful gem that acts as <b>any</b> Alloha to help you complete a line. It appears once per game.</li>
                    <li><b>Cursed Block (☠️):</b> An immovable obstacle that cannot be changed or removed by any superpower. It also appears once per game.</li>
                </ul>
            
                <h3 class="font-bold text-lg" style="color: var(--accent);">📈 Scoring & Bonuses</h3>
                <p>Points are awarded for creating lines of 3 or more matching Allohas in rows or columns.</p>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>3 in a line:</b> 3 points</li>
                    <li><b>4 in a line:</b> 5 points</li>
                    <li><b>5 in a line:</b> 8 points</li>
                    <li><b>6 in a line:</b> 12 points</li>
                    <li><b>7 in a line:</b> 20 points</li>
                </ul>
                <p>On top of that, you can earn big with these bonuses:</p>
                <ul class="list-disc list-inside space-y-1">
                    <li><b>Twinning Bonus:</b> Create sequences on the special <b>highlighted pattern</b>. You score points for these lines <b>in addition</b> to their normal row or column score!</li>
                    <li><b>Grid Bonus:</b> Form a square of 2x2, 3x3, or larger with the same Alloha to earn bonus points equal to its size squared (e.g., a 2x2 grid gives 4 bonus points).</li>
                </ul>
                
                <h3 class="font-bold text-lg" style="color: var(--accent);">👑 The Golden Alloha</h3>
                <p>The game isn't over until the final move is made! When the grid is full or you can't make any more moves, you get to place one final <b>Golden Alloha</b>.</p>
                <ul class="list-disc list-inside space-y-1">
                    <li>You can choose <b>any symbol</b> from the game's set.</li>
                    <li>You can place it in <b>any available empty square</b> on the board. Make it count!</li>
                </ul>

                <h3 class="font-bold text-lg" style="color: var(--accent);">💣 Empty Block</h3>
                <p>After you place your Golden Alloha, any other spaces that are still empty will be filled with Stuck Blocks (💣). Each one contributes to the <b>Empty Block</b>, a penalty against your final score, so try to fill the grid completely!</p>

                <h3 class="font-bold text-lg" style="color: var(--accent);">Penalty</h3>
                <p>Be careful! Any row, column, or Twinning Pattern line that can no longer form a 3-symbol sequence will also receive a <b>-5 point penalty</b>.</p>
            
                <p class="pt-4 italic">Have fun. And if you have read till here, then DM @sonofarjuna for a free chocolate.</p>
            </div>
        </div>
    </div>
    
    <div id="edition-select-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm themed-modal p-6 transform scale-95 -translate-y-4">
            <div class="flex justify-between items-center mb-4">
                 <h2 class="text-2xl font-bold" style="color: var(--accent);">Select Edition</h2>
                 <button id="close-edition-select-btn" aria-label="Close Select Edition" class="w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            </div>
            <div class="flex items-center justify-center mb-4 space-x-4">
                <span id="classic-text" class="font-semibold" style="color: var(--text-secondary)">Classic</span>
                <div id="mode-toggle-switch" class="w-14 h-8 flex items-center rounded-full p-1 cursor-pointer">
                    <div id="mode-toggle-thumb" class="bg-white w-6 h-6 rounded-full shadow-md transform transition-transform"></div>
                </div>
                <span id="time-burst-text" class="font-semibold" style="color: var(--text-secondary)">Time Burst</span>
            </div>
            <div id="edition-options" class="flex flex-col gap-3 max-h-64 overflow-y-auto"></div>
        </div>
    </div>
    
    <div id="confirm-restart-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm themed-modal p-8 text-center transform scale-95 -translate-y-4">
            <h2 class="text-2xl font-bold mb-4" style="color: var(--accent);">Restart Game?</h2>
            <p class="mb-6" style="color: var(--text-secondary);">Your current progress will be lost. Are you sure?</p>
            <div class="flex justify-center items-center gap-3">
                <button id="confirm-cancel-btn" class="flex-1 py-2 px-4 themed-button text-sm" style="color: var(--text-secondary); background: rgba(0,0,0,0.05);">Cancel</button>
                <button id="confirm-restart-btn" class="flex-1 py-2 px-4 themed-button text-white text-sm">Restart</button>
            </div>
        </div>
    </div>

    <div id="game-over-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-md text-center themed-modal p-8 transform scale-95 -translate-y-4 relative">
            <button id="close-game-over-btn" aria-label="Close Game Over" class="absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-4xl font-bold mb-2" style="font-family: 'Pacifico', cursive; color: var(--accent);">Game Over Alloha!</h2>
            <p id="game-over-reason" class="text-lg mt-2 mb-4" style="color: var(--accent);"></p>
            <div id="final-score-modal" class="text-7xl font-bold my-4" style="color: var(--accent);"></div>
            <div id="score-breakdown" class="mb-6 p-4 glass-card rounded-xl text-xs" style="display: grid;">
                <div class="grid grid-cols-2 gap-2">
                    <div class="text-left">Rows: <span id="final-rows-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Columns: <span id="final-cols-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Twinning: <span id="final-cross-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Bonus Grids: <span id="final-bonus-score" class="float-right font-bold">0</span></div>
                    <div class="text-left">Hero Bonus: <span id="final-hero-score" class="float-right font-bold">0</span></div>
                    <div class="text-left col-span-2 border-t pt-2 mt-2">Empty Block: <span id="final-penalty-score" class="float-right font-bold">0</span></div>
                </div>
            </div>
            <p>High score: <span id="high-score-modal" class="font-bold" style="color: #FFC107;">0</span></p>
            <div id="game-over-buttons" class="flex flex-col items-center gap-3 mt-6">
                <div class="flex w-full items-center gap-3">
                    <button id="play-again-btn" class="flex-1 themed-button text-white font-bold py-3 px-4 rounded-xl text-lg">Play Again</button>
                    <button id="share-score-btn" class="flex-1 themed-button text-white font-bold py-3 px-4 rounded-xl text-lg flex items-center justify-center gap-2" style="background: var(--accent-gradient-shaded);">
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 20 20" fill="currentColor">
                            <path d="M15 8a3 3 0 10-2.977-2.63l-4.94 2.47a3 3 0 100 4.319l4.94 2.47a3 3 0 10.895-1.789l-4.94-2.47a3.027 3.027 0 000-.74l4.94-2.47C13.456 7.68 14.19 8 15 8z" />
                        </svg>
                        <span>Share Score</span>
                    </button>
                </div>
                <button id="change-edition-btn-modal" class="no-screenshot themed-button w-full py-2.5 px-4 text-sm font-semibold rounded-lg mt-2" style="color: var(--accent); background-color: var(--accent-light);">
                    Choose a different Game Edition
                </button>
            </div>
        </div>
    </div>

    <div id="exchange-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-sm text-center themed-modal p-6 transform scale-95 -translate-y-4">
            <h2 id="exchange-modal-title" class="text-xl font-bold mb-4" style="color: var(--accent);">Choose a new Alloha</h2>
            <div id="exchange-options" class="grid grid-cols-3 gap-4"></div>
        </div>
    </div>

    <div id="tutorial-modal" class="modal fixed inset-0 bg-black/60 flex items-center justify-center p-4 opacity-0 invisible z-50 backdrop-blur-sm">
        <div class="modal-content w-full max-w-md text-center themed-modal p-8 transform scale-95 -translate-y-4 relative">
            <button id="close-tutorial-btn" aria-label="Close Tutorial" class="absolute top-4 right-4 w-10 h-10 rounded-full text-xl flex items-center justify-center font-bold">×</button>
            <h2 class="text-4xl font-bold mb-2" style="font-family: 'Pacifico', cursive; color: var(--accent);">Welcome to Alloha!</h2>
            <div id="tutorial-content" class="text-lg mt-4 mb-6" style="color: var(--text-secondary);">
                </div>
            <div class="tutorial-progress flex justify-center mt-4 gap-2">
                <div class="tutorial-progress-dot active"></div>
                <div class="tutorial-progress-dot"></div>
                <div class="tutorial-progress-dot"></div>
                <div class="tutorial-progress-dot"></div>
            </div>
            <button id="tutorial-next-btn" class="themed-button text-white font-bold py-3 px-6 rounded-xl text-lg mt-6" style="background: var(--accent-gradient);">Next</button>
        </div>
    </div>

    <script>
    (function() { // <-- FIX 1: Start of IIFE wrapper
        // --- NEW: Helper functions for animations ---
        function createSparkles(element) {
            const rect = element.getBoundingClientRect();
            const container = document.body;
            for (let i = 0; i < 8; i++) {
                const sparkle = document.createElement('div');
                sparkle.className = 'sparkle';
                sparkle.style.top = `${rect.top + rect.height / 2}px`;
                sparkle.style.left = `${rect.left + rect.width / 2}px`;
                const randomAngle = Math.random() * 2 * Math.PI;
                const randomDist = Math.random() * 50 + 20;
                sparkle.style.setProperty('--sparkle-x', `${Math.cos(randomAngle) * randomDist}px`);
                sparkle.style.setProperty('--sparkle-y', `${Math.sin(randomAngle) * randomDist}px`);
                container.appendChild(sparkle);
                setTimeout(() => sparkle.remove(), 700);
            }
        }

        function showFloatingScore(text, sourceElement) {
            const floater = document.createElement('div');
            floater.className = 'floating-score';
            floater.textContent = text;
            const startRect = sourceElement.getBoundingClientRect();
            floater.style.top = `${startRect.top + startRect.height / 2 - 15}px`;
            floater.style.left = `${startRect.left + startRect.width / 2 - 15}px`;
            document.body.appendChild(floater);
            setTimeout(() => floater.remove(), 1200);
        }

        function animateScoreUpdate(containerId, newValue, minLength = 1) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            container.classList.add('digit-score-container');
            const oldValue = parseInt(container.dataset.currentValue || '0');
            if (newValue > oldValue) createSparkles(container);
            container.dataset.currentValue = newValue;

            const isNegative = newValue < 0;
            const absValueStr = String(Math.abs(newValue)).padStart(minLength, '0');

            // Handle Parentheses
            const openParenId = `paren-open-${containerId}`;
            const closeParenId = `paren-close-${containerId}`;
            let openParen = document.getElementById(openParenId);
            let closeParen = document.getElementById(closeParenId);

            if (isNegative) {
                if (!openParen) {
                    openParen = document.createElement('span');
                    openParen.id = openParenId;
                    openParen.className = 'score-parenthesis';
                    openParen.textContent = '(';
                    container.prepend(openParen);
                }
                if (!closeParen) {
                    closeParen = document.createElement('span');
                    closeParen.id = closeParenId;
                    closeParen.className = 'score-parenthesis';
                    closeParen.textContent = ')';
                    container.appendChild(closeParen);
                }
            } else {
                if (openParen) openParen.remove();
                if (closeParen) closeParen.remove();
            }

            // Handle Digits
            const numDigits = absValueStr.length;
            let existingDigitContainers = container.querySelectorAll('.digit-container');
            while (existingDigitContainers.length < numDigits) {
                const digitContainer = document.createElement('div');
                digitContainer.className = 'digit-container';
                let stripHTML = '';
                for(let i=0; i<10; i++) stripHTML += `<span>${i}</span>`;
                digitContainer.innerHTML = `<div class="digit-strip">${stripHTML}</div>`;
                if (closeParen) container.insertBefore(digitContainer, closeParen);
                else container.appendChild(digitContainer);
                existingDigitContainers = container.querySelectorAll('.digit-container');
            }
             while (existingDigitContainers.length > numDigits) {
                container.querySelector('.digit-container').remove();
                existingDigitContainers = container.querySelectorAll('.digit-container');
            }
            
            for (let i = 0; i < numDigits; i++) {
                const digit = parseInt(absValueStr[i]);
                const digitStrip = container.querySelectorAll('.digit-strip')[i];
                if (digitStrip) {
                    const yOffset = -digit * 10;
                    digitStrip.style.transform = `translateY(${yOffset}%)`;
                }
            }
        }
        // --- THEME CONFIGURATIONS ---
        const themeConfigs = {
            pastel_pals: { name: "Pastel Pals", symbols: ['🐰', '🐶', '🐯', '🐼', '🦄', '🐸'], palette: { bg: 'linear-gradient(135deg, #F3E5F5 0%, #E1BEE7 100%)', card: 'rgba(255, 255, 255, 0.88)', text: '#4A148C', text_secondary: '#7B1FA2', accent: '#8E24AA', accent_gradient: 'linear-gradient(135deg, #8E24AA 0%, #AB47BC 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #BA68C8 0%, #CE93D8 100%)', highlighted_bg: 'rgba(142, 36, 170, 0.15)', highlighted_border: 'rgba(142, 36, 170, 0.3)', grid_cell_bg: '#F9F6FB', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🐰':'text-pink-400', '🐶':'text-amber-600', '🐯':'text-orange-500', '🐼':'text-gray-700', '🦄':'text-purple-500', '🐸':'text-green-500' } },
            green_grocer: { name: "Green Grocer", symbols: ['🥑', '🥦', '🧄', '🌽', '🫑', '🌶️'], palette: { bg: 'linear-gradient(135deg, #F1F8E9 0%, #DCEDC8 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#33691E', text_secondary: '#689F38', accent: '#8BC34A', accent_gradient: 'linear-gradient(135deg, #8BC34A 0%, #9CCC65 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #AED581 0%, #C5E1A5 100%)', highlighted_bg: 'rgba(139, 195, 74, 0.15)', highlighted_border: 'rgba(139, 195, 74, 0.3)', grid_cell_bg: '#FCFFF5', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🥑':'text-green-800', '🥦':'text-green-600', '🧄':'text-gray-500', '🌽':'text-yellow-500', '🫑':'text-green-700', '🌶️':'text-red-600' } },
            bug_life: { name: "Bug's Life", symbols: ['🦋', '🐝', '🪲', '🐛', '🐞', '🪰'], palette: { bg: 'linear-gradient(135deg, #E0F2F1 0%, #B2DFDB 100%)', card: 'rgba(255, 255, 255, 0.85)', text: '#004D40', text_secondary: '#00796B', accent: '#009688', accent_gradient: 'linear-gradient(135deg, #009688 0%, #26A69A 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #4DB6AC 0%, #80CBC4 100%)', highlighted_bg: 'rgba(0, 150, 136, 0.15)', highlighted_border: 'rgba(0, 150, 136, 0.3)', grid_cell_bg: '#F5FCFB', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🦋':'text-blue-500', '🐝':'text-yellow-500', '🪲':'text-amber-800', '🐛':'text-lime-600', '🐞':'text-red-600', '🪰':'text-gray-700' } },
            hats_off: { name: "Hats Off", symbols: ['🪖', '🎩', '🧢', '👒', '⛑️', '👑'], palette: { bg: 'linear-gradient(135deg, #A1887F 0%, #795548 100%)', card: 'rgba(255, 255, 255, 0.85)', text: '#3E2723', text_secondary: '#5D4037', accent: '#FFD700', accent_light: '#6D4C41', accent_gradient: 'linear-gradient(135deg, #FFD700 0%, #FFC107 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #5D4037 0%, #4E342E 100%)', highlighted_bg: 'rgba(255, 215, 0, 0.45)', highlighted_border: 'rgba(255, 215, 0, 0.6)', grid_cell_bg: '#EFEBE9', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🪖':'text-green-800', '🎩':'text-gray-800', '🧢':'text-blue-600', '👒':'text-pink-400', '⛑️':'text-red-600', '👑':'text-yellow-500' } },
            golden_bakery: { name: "Golden Bakery", symbols: ['🍞', '🥯', '🥐', '🧇', '🍪', '🥞'], palette: { bg: 'linear-gradient(135deg, #FFF8E1 0%, #FFECB3 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#8D6E63', text_secondary: '#A1887F', accent: '#AF8260', accent_gradient: 'linear-gradient(135deg, #AF8260 0%, #C19A7B 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #D4B298 0%, #E6C9B4 100%)', highlighted_bg: 'rgba(175, 130, 96, 0.15)', highlighted_border: 'rgba(175, 130, 96, 0.3)', grid_cell_bg: '#FFFBF2', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🍞':'text-amber-800', '🥯':'text-amber-700', '🥐':'text-orange-600', '🧇':'text-yellow-700', '🍪':'text-amber-900', '🥞':'text-amber-600' } },
             sporty_vibes: { name: "Sporty Vibes", symbols: ['🏀', '⚽️', '🥎', '🏉', '🏐', '🏈'], palette: { bg: 'linear-gradient(135deg, #4CAF50 0%, #388E3C 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#1B5E20', text_secondary: '#2E7D32', accent: '#FF9800', accent_gradient: 'linear-gradient(135deg, #FF9800 0%, #FFA726 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFB74D 0%, #FFCC80 100%)', highlighted_bg: 'rgba(255, 152, 0, 0.45)', highlighted_border: 'rgba(255, 152, 0, 0.6)', grid_cell_bg: '#F1F8E9', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🏀':'text-orange-600', '⚽️':'text-black', '🥎':'text-lime-400', '🏉':'text-amber-800', '🏐':'text-blue-500', '🏈':'text-amber-900' } },
            school_of_magic: { name: "School of Magic", symbols: ['🧙‍♀️', '🦉', '📜', '🏆', '🏟️', '🔮'], palette: { bg: 'linear-gradient(135deg, #4E342E 0%, #212121 100%)', card: 'rgba(78, 52, 46, 0.75)', text: '#FFECB3', text_secondary: '#D7CCC8', accent: '#D32F2F', accent_gradient: 'linear-gradient(135deg, #D32F2F 0%, #FFC107 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #EF5350 0%, #FFD54F 100%)', highlighted_bg: 'rgba(211, 47, 47, 0.15)', highlighted_border: 'rgba(211, 47, 47, 0.3)', grid_cell_bg: '#6D4C41', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '🧙‍♀️':'text-purple-300', '🦉':'text-gray-300', '📜':'text-yellow-200', '🏆':'text-yellow-400', '🏟️':'text-gray-400', '🔮':'text-purple-400' } },
            emoji_fun: { name: "Emoji Fun", symbols: ['😍', '😎', '🤩', '😂', '🥵', '🤯'], palette: { bg: 'linear-gradient(135deg, #FFF9C4 0%, #FFF176 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#4E342E', text_secondary: '#795548', accent: '#42A5F5', accent_gradient: 'linear-gradient(135deg, #42A5F5 0%, #64B5F6 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #90CAF9 0%, #BBDEFB 100%)', highlighted_bg: 'rgba(66, 165, 245, 0.15)', highlighted_border: 'rgba(66, 165, 245, 0.3)', grid_cell_bg: '#FFFDE7', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '😍':'text-red-500', '😎':'text-black', '🤩':'text-yellow-600', '😂':'text-blue-500', '🥵':'text-orange-500', '🤯':'text-purple-500' } },
            deep_ocean: { name: "Deep Ocean", symbols: ['🐡', '🦑', '🦀', '🐙', '🐳', '🐠'], palette: { bg: 'linear-gradient(135deg, #1A237E 0%, #0D47A1 100%)', card: 'rgba(26, 35, 126, 0.7)', text: '#E3F2FD', text_secondary: '#90CAF9', accent: '#42A5F5', accent_gradient: 'linear-gradient(135deg, #42A5F5 0%, #64B5F6 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #90CAF9 0%, #BBDEFB 100%)', highlighted_bg: 'rgba(66, 165, 245, 0.2)', highlighted_border: 'rgba(66, 165, 245, 0.4)', grid_cell_bg: '#1976D2', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '🐡':'text-yellow-300', '🦑':'text-pink-300', '🦀':'text-red-400', '🐙':'text-purple-300', '🐳':'text-blue-300', '🐠':'text-orange-300' } },
            road_block_theme: { name: "Road Block", symbols: ['🚑', '🚌', '🚗', '🚎', '🚜', '✈️'], palette: { bg: 'linear-gradient(135deg, #B0BEC5 0%, #78909C 100%)', card: 'rgba(255, 255, 255, 0.8)', text: '#263238', text_secondary: '#455A64', accent: '#FFC107', accent_gradient: 'linear-gradient(135deg, #FFCA28 0%, #FFD54F 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFE082 0%, #FFEE58 100%)', highlighted_bg: 'rgba(255, 193, 7, 0.15)', highlighted_border: 'rgba(255, 193, 7, 0.3)', grid_cell_bg: '#ECEFF1', toggle_bg_inactive: 'rgba(0,0,0,0.2)', }, symbolColors: { '🚑':'text-red-500', '🚌':'text-yellow-500', '🚗':'text-blue-500', '🚎':'text-green-500', '🚜':'text-orange-500', '✈️':'text-gray-400' } },
            the_post_office: { name: "The Post Office", symbols: ['📦', '📮', '🗂️', '🗳️', '🗄️', '📬'], palette: { bg: 'linear-gradient(135deg, #EFEBE9 0%, #D7CCC8 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#3E2723', text_secondary: '#6D4C41', accent: '#D32F2F', accent_gradient: 'linear-gradient(135deg, #D32F2F 0%, #E53935 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #EF5350 0%, #E57373 100%)', highlighted_bg: 'rgba(211, 47, 47, 0.1)', highlighted_border: 'rgba(211, 47, 47, 0.25)', grid_cell_bg: '#F8F5F3', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '📦':'text-amber-800', '📮':'text-red-600', '🗂️':'text-gray-500', '🗳️':'text-blue-700', '🗄️':'text-gray-600', '📬':'text-red-700' } },
            tutti_frutti: { name: "Tutti Frutti", symbols: ['🍓', '🫐', '🍉', '🥝', '🥭', '🍋'], palette: { bg: 'linear-gradient(135deg, #FFFFFF 0%, #F5F5F5 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#4E342E', text_secondary: '#6D4C41', accent: '#EC407A', accent_gradient: 'linear-gradient(135deg, #EC407A 0%, #F06292 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #F48FB1 0%, #F8BBD0 100%)', highlighted_bg: 'rgba(236, 64, 122, 0.1)', highlighted_border: 'rgba(236, 64, 122, 0.25)', grid_cell_bg: '#FFFFFF', toggle_bg_inactive: '#F0F0F0', }, symbolColors: { '🍓':'text-red-500', '🫐':'text-blue-600', '🍉':'text-green-600', '🥝':'text-lime-700', '🥭':'text-orange-500', '🍋':'text-yellow-500' } },
            zedi_zodi: { name: "Zodiac Night", symbols: ['♋', '♒', '♎', '♐', '♌', '♉'], palette: { bg: 'linear-gradient(135deg, #0f0c29 0%, #302b63 100%)', card: 'rgba(48, 43, 99, 0.75)', text: '#FFFFFF', text_secondary: '#A9B4D1', accent: '#FFD700', accent_gradient: 'linear-gradient(135deg, #FFD700 0%, #FFA000 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFECB3 0%, #FFD54F 100%)', highlighted_bg: 'rgba(255, 215, 0, 0.15)', highlighted_border: 'rgba(255, 215, 0, 0.3)', grid_cell_bg: '#6A6E89', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '♋':'text-gray-300', '♒':'text-blue-300', '♎':'text-pink-300', '♐':'text-orange-300', '♌':'text-yellow-300', '♉':'text-green-300' } },
            desert_oasis: { name: "Desert Oasis", symbols: ['🌵', '🪨', '☀️', '🐍', '⛺', '🌴'], palette: { bg: 'linear-gradient(135deg, #FFECB3 0%, #FFD54F 100%)', card: 'rgba(255, 255, 255, 0.85)', text: '#5D4037', text_secondary: '#6D4C41', accent: '#00897B', accent_gradient: 'linear-gradient(135deg, #00897B 0%, #26A69A 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #4DB6AC 0%, #80CBC4 100%)', highlighted_bg: 'rgba(0, 137, 123, 0.15)', highlighted_border: 'rgba(0, 137, 123, 0.3)', grid_cell_bg: '#FFFBF2', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🌵':'text-green-700', '🪨':'text-gray-600', '☀️':'text-yellow-600', '🐍':'text-emerald-800', '⛺':'text-orange-700', '🌴':'text-lime-800' } },
            morning_aviary: { name: "Morning Aviary", symbols: ['🐔', '🐦', '🐥', '🐣', '🐝', '🐧'], palette: { bg: 'linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#0D47A1', text_secondary: '#1976D2', accent: '#FFA000', accent_gradient: 'linear-gradient(135deg, #FFA000 0%, #FFB300 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFC107 0%, #FF8F00 100%)', highlighted_bg: 'rgba(255, 160, 0, 0.15)', highlighted_border: 'rgba(255, 160, 0, 0.3)', grid_cell_bg: '#F7FBFF', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🐔':'text-red-600', '🐦':'text-blue-500', '🐥':'text-yellow-500', '🐣':'text-yellow-400', '🐝':'text-yellow-600', '🐧':'text-gray-800' } },
            creepy_crawlies: { name: "Creepy Crawlies", symbols: ['🐍', '🦎', '🦂', '🐭', '🥚', '🐁'], palette: { bg: 'linear-gradient(135deg, #37474F 0%, #212121 100%)', card: 'rgba(38, 50, 56, 0.8)', text: '#CFD8DC', text_secondary: '#90A4AE', accent: '#7E57C2', accent_gradient: 'linear-gradient(135deg, #7E57C2 0%, #9575CD 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #B39DDB 0%, #D1C4E9 100%)', highlighted_bg: 'rgba(126, 87, 194, 0.15)', highlighted_border: 'rgba(126, 87, 194, 0.3)', grid_cell_bg: '#546E7A', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '🐍':'text-green-400', '🦎':'text-lime-400', '🦂':'text-red-400', '🐭':'text-gray-300', '🥚':'text-gray-200', '🐁':'text-gray-100' } },
            ancient_secrets: { name: "Ancient Secrets", symbols: ['🔍', '🧩', '🀄', '🔑', '🧭', '👁️'], palette: { bg: 'linear-gradient(135deg, #5D4037 0%, #3E2723 100%)', card: 'rgba(62, 39, 35, 0.75)', text: '#D7CCC8', text_secondary: '#D7CCC8', accent: '#FFCA28', accent_gradient: 'linear-gradient(135deg, #FFC107 0%, #FF8F00 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFA000 0%, #FF6F00 100%)', highlighted_bg: 'rgba(255, 202, 40, 0.15)', highlighted_border: 'rgba(255, 202, 40, 0.3)', grid_cell_bg: '#795548', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '🔍':'text-blue-300', '🧩':'text-orange-300', '🀄':'text-red-300', '🔑':'text-yellow-300', '🧭':'text-gray-300', '👁️':'text-cyan-300' } },
            cosmic_drift: { name: "Cosmic Drift", symbols: ['🌍', '🚀', '🪐', '🌗', '💫', '🛰️'], palette: { bg: 'linear-gradient(135deg, #1A237E 0%, #0D123B 100%)', card: 'rgba(48, 59, 128, 0.7)', text: '#E8EAF6', text_secondary: '#9FA8DA', accent: '#536DFE', accent_gradient: 'linear-gradient(135deg, #536DFE 0%, #7C4DFF 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #7C4DFF 0%, #B388FF 100%)', highlighted_bg: 'rgba(83, 109, 254, 0.2)', highlighted_border: 'rgba(83, 109, 254, 0.4)', grid_cell_bg: '#5C6BC0', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '🌍':'text-blue-300', '🚀':'text-gray-200', '🪐':'text-amber-300', '🌗':'text-gray-100', '💫':'text-yellow-300', '🛰️':'text-blue-200' } },
            petal_meadow: { name: "Petal Meadow", symbols: ['🌸', '🌺', '🌷', '🪷', '🪻', '🌻'], palette: { bg: 'linear-gradient(135deg, #E6EE9C 0%, #C5E1A5 100%)', card: 'rgba(255, 255, 255, 0.9)', text: '#2E7D32', text_secondary: '#558B2F', accent: '#D81B60', accent_gradient: 'linear-gradient(135deg, #D81B60 0%, #E91E63 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #F06292 0%, #F48FB1 100%)', highlighted_bg: 'rgba(216, 27, 96, 0.1)', highlighted_border: 'rgba(216, 27, 96, 0.25)', grid_cell_bg: '#F8FFF0', toggle_bg_inactive: '#E0E0E0', }, symbolColors: { '🌸':'text-pink-400', '🌺':'text-red-500', '🌷':'text-orange-500', '🪷':'text-pink-500', '🪻':'text-purple-500', '🌻':'text-yellow-500' } },
            monster_mash: { name: "Monster Mash", symbols: ['👹', '🐲', '👻', '👽', '🎃', '😈'], palette: { bg: 'linear-gradient(135deg, #432874 0%, #18142a 100%)', card: 'rgba(40, 30, 60, 0.8)', text: '#E0D6FF', text_secondary: '#BCA9F0', accent: '#FF7900', accent_gradient: 'linear-gradient(135deg, #FF7900 0%, #FF983D 100%)', accent_gradient_shaded: 'linear-gradient(135deg, #FFB47A 0%, #FFD0B1 100%)', highlighted_bg: 'rgba(255, 121, 0, 0.15)', highlighted_border: 'rgba(255, 121, 0, 0.3)', grid_cell_bg: '#4A3F71', toggle_bg_inactive: 'rgba(255,255,255,0.2)', }, symbolColors: { '👹':'text-red-400', '🐲':'text-green-400', '👻':'text-gray-200', '👽':'text-lime-300', '🎃':'text-orange-400', '😈':'text-purple-400' } }
        };

        function applyTheme(themeId) {
            const theme = themeConfigs[themeId];
            if (!theme) {
                console.warn(`Theme "${themeId}" not found.`);
                return;
            }
            const root = document.documentElement;
            const palette = theme.palette;
            for (const key in palette) {
                root.style.setProperty(`--${key.replace(/_/g, '-')}`, palette[key]);
            }
        }

        const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

        const generateCrossScoreSegments = (isTwinningCell) => {
            const segments = [];
            const GRID_SIZE = 7;

            const processLine = (lineType, index) => {
                let currentSegment = null;
                for (let i = 0; i < GRID_SIZE; i++) {
                    const isTwinning = (lineType === 'row') ? isTwinningCell(index, i) : isTwinningCell(i, index);
                    if (isTwinning) {
                        if (currentSegment === null) {
                            currentSegment = { type: lineType, index: index, start: i, end: i };
                        } else {
                            currentSegment.end = i;
                        }
                    } else {
                        if (currentSegment !== null) {
                            segments.push(currentSegment);
                            currentSegment = null;
                        }
                    }
                }
                if (currentSegment !== null) {
                    segments.push(currentSegment);
                }
            };

            for (let r = 0; r < GRID_SIZE; r++) {
                processLine('row', r);
            }
            for (let c = 0; c < GRID_SIZE; c++) {
                processLine('col', c);
            }
            
            return segments;
        };
        
        // --- VARIANT CONFIGURATIONS ---
        const variantConfigs = {
            'plain_jean': { id: 'plain_jean', name: 'Plain Jean', themeId: 'pastel_pals', timeLimit: 100, isTwinningCell: (r, c) => false, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'one_won': { id: 'one_won', name: 'One Won', themeId: 'green_grocer', timeLimit: 100, isTwinningCell: (r, c) => c === 3, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'plus_minus': { id: 'plus_minus', name: 'Plus Minus', themeId: 'bug_life', timeLimit: 100, isTwinningCell: (r, c) => r === 3 || c === 3, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'hat_trick': { id: 'hat_trick', name: 'Hat Trick', themeId: 'hats_off', timeLimit: 100, isTwinningCell: (r, c) => r === 0 || r === 6 || c === 0, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'sugar_cube': { id: 'sugar_cube', name: 'Sugar Cube', themeId: 'golden_bakery', timeLimit: 100, isTwinningCell: (r, c) => r === 0 || r === 6 || c === 0 || c === 6, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'spoil_sport': { id: 'spoil_sport', name: 'Spoil Sport', themeId: 'sporty_vibes', timeLimit: 100, isTwinningCell: (r, c) => r === 0 || r === 3 || c === 0 || c === 6, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'marry_harry': { id: 'marry_harry', name: 'Marry Harry', themeId: 'school_of_magic', timeLimit: 100, isTwinningCell: (r, c) => c === 1 || c === 5 || (r === 3 && c >= 1 && c <= 5), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'cosy_emoji': { id: 'cosy_emoji', name: 'Cosy Emoji', themeId: 'emoji_fun', timeLimit: 100, isTwinningCell: (r, c) => r === 0 || r === 3 || r === 6 || c === 0, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'wonder_wander': { id: 'wonder_wander', name: 'Wonder Wander', themeId: 'deep_ocean', timeLimit: 120, isTwinningCell: (r, c) => r === 6 || [0, 3, 6].includes(c), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'road_block': { id: 'road_block', name: 'Road Block', themeId: 'road_block_theme', timeLimit: 120, isTwinningCell: (r, c) => [0, 2, 4, 6].includes(c), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'box_vox': { id: 'box_vox', name: 'Box Vox', themeId: 'the_post_office', timeLimit: 120, isTwinningCell: (r, c) => [0, 3, 6].includes(r) || [0, 3, 6].includes(c), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'hash_hush': { id: 'hash_hush', name: 'Hash Hush', themeId: 'tutti_frutti', timeLimit: 120, isTwinningCell: (r, c) => [2, 4].includes(r) || [2, 4].includes(c), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'zedi_zodi': { id: 'zedi_zodi', name: 'Zedi Zodi', themeId: 'zedi_zodi', timeLimit: 120, isTwinningCell: (r, c) => r === 0 || r === 6 || r + c === 6, getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'core': { id: 'core', name: 'Cacti Facti Edition', themeId: 'desert_oasis', timeLimit: 150, isTwinningCell: (r, c) => (r === 3 && c >= 3 && c <= 5) || (r === 5 && c >= 1 && c <= 3) || (c === 1 && r >= 1 && r <= 5) || (c === 3) || (c === 5 && r >= 0 && r <= 3), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'eight_and_watch': { id: 'eight_and_watch', name: 'Eight and Watch', themeId: 'morning_aviary', timeLimit: 150, isTwinningCell: (r, c) => (r === 0 && c >= 3) || (r === 3) || (r === 6 && c <= 3) || (c === 0 && r >= 3) || (c === 3) || (c === 6 && r <= 3), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'fake_snake': { id: 'fake_snake', name: 'Fake Snake', themeId: 'creepy_crawlies', timeLimit: 150, isTwinningCell: (r, c) => (r === 0 && c >= 4) || (r === 2 && c >= 2 && c <= 4) || (r === 4 && c <= 2) || (c === 0 && r >= 4) || (c === 2 && r >= 2 && r <= 4) || (c === 4 && r <= 2), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'rune_dune': { id: 'rune_dune', name: 'Rune Dune', themeId: 'ancient_secrets', timeLimit: 150, isTwinningCell: (r, c) => (r === 2 && c >= 1 && c <= 5) || (r === 4 && c >= 1 && c <= 5) || (c === 1 && (r <= 2 || r >= 4)) || (c === 3) || (c === 5 && (r <= 2 || r >= 4)), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'space_race': { id: 'space_race', name: 'Space Race', themeId: 'cosmic_drift', timeLimit: 180, isTwinningCell: (r, c) => (r === 2 && c >= 2 && c <= 4) || (r === 3 && (c <= 2 || c >= 4)) || (r === 4 && c >= 2 && c <= 4) || (c === 2 && r >= 2 && r <= 4) || (c === 3 && (r <= 2 || r >= 4)) || (c === 4 && r >= 2 && r <= 4), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'flower_power': { id: 'flower_power', name: 'Flower Power', themeId: 'petal_meadow', timeLimit: 180, isTwinningCell: (r, c) => (r === 0 && c >= 2 && c <= 4) || (r === 2 && c >= 2 && c <= 4) || r === 4 || (c === 1 && r >= 3 && r <= 5) || (c === 2 && r <= 2) || (c === 3 && r >= 2) || (c === 4 && r <= 2) || (c === 5 && r >= 3 && r <= 5), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } },
            'monster': { id: 'monster', name: 'Monster Monster', themeId: 'monster_mash', timeLimit: 180, isTwinningCell: (r, c) => (r === 0 && c <= 2) || (r === 2 && c <= 4) || (r === 3 && c >= 4) || (r === 4 && c >= 2 && c <= 4) || (r === 6 && c <= 3) || (c === 0 && r <= 2) || (c === 2 && r <= 4) || (c === 3 && r >= 4) || (c === 4 && r >= 2 && r <= 4), getCrossScoreSegments: function() { return generateCrossScoreSegments(this.isTwinningCell); } }
        };

        class GameState {
            constructor() {
                this.states = {
                    PRE_GAME: 'PRE_GAME',
                    AWAITING_ROLL: 'AWAITING_ROLL',
                    ANIMATING_ROLL: 'ANIMATING_ROLL',
                    AWAITING_PLACEMENT: 'AWAITING_PLACEMENT',
                    SUPERPOWER_ACTIVE: 'SUPERPOWER_ACTIVE',
                    PROCESSING_TURN: 'PROCESSING_TURN',
                    AWAITING_GOLDEN_PLACEMENT: 'AWAITING_GOLDEN_PLACEMENT',
                    GAME_OVER: 'GAME_OVER'
                };
                this.currentState = this.states.PRE_GAME;
                this.validTransitions = {
                    [this.states.PRE_GAME]: [this.states.AWAITING_ROLL],
                    [this.states.AWAITING_ROLL]: [this.states.ANIMATING_ROLL, this.states.PRE_GAME, this.states.SUPERPOWER_ACTIVE, this.states.AWAITING_PLACEMENT, this.states.AWAITING_GOLDEN_PLACEMENT],
                    [this.states.ANIMATING_ROLL]: [this.states.AWAITING_PLACEMENT],
                    [this.states.AWAITING_PLACEMENT]: [this.states.PROCESSING_TURN, this.states.AWAITING_ROLL, this.states.SUPERPOWER_ACTIVE],
                    [this.states.SUPERPOWER_ACTIVE]: [this.states.AWAITING_ROLL, this.states.AWAITING_PLACEMENT, this.states.PROCESSING_TURN],
                    [this.states.PROCESSING_TURN]: [this.states.AWAITING_ROLL, this.states.GAME_OVER, this.states.AWAITING_GOLDEN_PLACEMENT],
                    [this.states.AWAITING_GOLDEN_PLACEMENT]: [this.states.GAME_OVER],
                    [this.states.GAME_OVER]: [this.states.PRE_GAME]
                };
            }
            setState(newState) { if (!this.validTransitions[this.currentState]?.includes(newState)) { console.warn(`Invalid state transition from ${this.currentState} to ${newState}`); return false; } this.currentState = newState; return true; }
            is(state) { return this.currentState === state; }
        }

        class Game {
            constructor(variantConfig, themeConfig, isTimeBurst, savedState = null) {
                this.config = variantConfig;
                this.theme = themeConfig;
                this.isTimeBurst = isTimeBurst;
                this.timerId = null;
                this.timeLeft = this.config.timeLimit;
                
                this.tutorialMode = false;
                this.tutorialStep = 0;
                this.tutorialModal = null;
                
                this.SYMBOLS = this.theme.symbols;
                this.SYMBOL_COLORS = this.theme.symbolColors;
                this.SPECIAL_SYMBOLS = { 'WILD': '💎', 'CURSED': '☠️' };

                this.SCORING_RULES = { 7: 20, 6: 12, 5: 8, 4: 5, 3: 3 };
                this.GRID_SIZE = 7; this.MAX_TURNS = 24; this.CROSS_MULTIPLIER = 2; this.LINE_DEATH_PENALTY = -5; this.CROSS_DEATH_PENALTY = -5; this.MIN_SEQUENCE_LENGTH = 3;
                
                this.gridCells = [];
                this.audio = { unlocked: false, context: null, sounds: new Map() };
                this.DOMElements = this.getDOMElements();
                
                this.init(savedState);
                this.setupEventListeners();
            }

            getDOMElements() {
                const elements = {};
                const idMap = {
                    game_board: 'game-board', row_scores_display: 'row-scores-display',
                    col_scores_display: 'col-scores-display', total_score: 'total-score', high_score: 'high-score',
                    rows_total_score: 'rows-total-score', cols_total_score: 'cols-total-score', cross_total_score: 'cross-total-score',
                    bonus_grid_score: 'bonus-grid-score', empty_block_penalty: 'empty-block-penalty', hero_bonus_score: 'hero-bonus-score',
                    rules_btn: 'rules-btn', rules_modal: 'rules-modal', close_rules_btn: 'close-rules-btn', 
                    game_over_modal: 'game-over-modal', game_over_reason: 'game-over-reason', close_game_over_btn: 'close-game-over-btn',
                    final_score_modal: 'final-score-modal', high_score_modal: 'high-score-modal', play_again_btn: 'play-again-btn',
                    final_rows_score: 'final-rows-score', final_cols_score: 'final-cols-score', final_cross_score: 'final-cross-score',
                    final_bonus_score: 'final-bonus-score', final_hero_score: 'final-hero-score', final_penalty_score: 'final-penalty-score',
                    exchange_modal: 'exchange-modal', exchange_options: 'exchange-options', progress_bar_fill: 'progress-bar-fill',
                    new_game_btn: 'new-game-btn', game_board_container: 'game-board-container', scoring_panel: 'scoring-panel',
                    effects_container: 'effects-container', rules_title: 'rules-title', 
                    in_game_content: 'in-game-content', pre_game_content: 'pre-game-content',
                    'in_game_content_wrapper': 'in_game_content_wrapper',
                    tutorial_modal: 'tutorial-modal', tutorial_content: 'tutorial-content', tutorial_next_btn: 'tutorial-next-btn', close_tutorial_btn: 'close-tutorial-btn',
                    warning_modal: 'warning-modal', close_warning_btn: 'close-warning-btn'
                };
                
                for (const key in idMap) {
                    const element = document.getElementById(idMap[key]);
                    if (!element) {
                        console.warn(`[Alloha Dev Warning] DOM element not found for key: "${key}" with ID: "${idMap[key]}"`);
                    }
                    elements[key] = element;
                }
                return elements;
            }

            init(savedState = null) {
                this.stopTimer();
                this.gridData = Array(this.GRID_SIZE).fill(null).map(() => Array(this.GRID_SIZE).fill(null));
                this.currentRoll = [];
                this.firstPlacementCell = null;
                this.turnCount = 0;
                this.stuckBlocks = new Set();
                this.usedSuperpowers = new Set();
                this.activeSuperpower = null;
                this.lastGameState = null;
                this.lastMoveCoords = null;
                this.currentTotalScore = 0;
                this.scores = { rows: 0, cols: 0, cross: 0, bonus: 0, hero: 0, penalty: 0 };
                this.gameStateManager = new GameState();

                if (savedState) {
                    this.gridData = JSON.parse(savedState.gridData);
                    this.currentRoll = savedState.currentRoll;
                    this.firstPlacementCell = savedState.firstPlacementCell;
                    this.turnCount = savedState.turnCount;
                    this.stuckBlocks = new Set(savedState.stuckBlocks);
                    this.usedSuperpowers = new Set(savedState.usedSuperpowers);
                    this.lastGameState = savedState.lastGameState ? { ...this.lastGameState, gridData: JSON.parse(savedState.lastGameState.gridData), stuckBlocks: new Set(savedState.lastGameState.stuckBlocks) } : null;
                    this.activeSuperpower = savedState.activeSuperpower;
                    this.currentTotalScore = savedState.currentTotalScore;
                    this.cursedBlockTurn = savedState.cursedBlockTurn;
                    this.wildcardTurn = savedState.wildcardTurn;
                    this.heroSymbol = savedState.heroSymbol;
                    this.heroBlocks = new Set(savedState.heroBlocks);
                    this.gameStateManager.currentState = savedState.currentState;
                    this.timeLeft = savedState.timeLeft;
                    if(this.isTimeBurst && this.turnCount > 0 && !this.gameStateManager.is('GAME_OVER')) this.startTimer();

                } else {
                    this.gameStateManager.setState('AWAITING_ROLL');
                    this.timeLeft = this.config.timeLimit;
                    this.cursedBlockTurn = Math.floor(Math.random() * 8) + 5;
                    this.wildcardTurn = Math.floor(Math.random() * 8) + 15;
                    if (this.wildcardTurn === this.cursedBlockTurn) this.wildcardTurn++;
                    this.initializeHeroFeature();
                    this.initTutorial();
                }

                this.cellToExchange = null; this.swapFirstCell = null;
                
                const highScoreKey = `cactiFactiHighScore_${this.config.id}_${this.isTimeBurst ? 'timeburst' : 'classic'}`;
                this.highScore = parseInt(localStorage.getItem(highScoreKey)) || 0;
                animateScoreUpdate('high-score', this.highScore, 3);

                ['game-over-modal', 'exchange-modal', 'rules-modal', 'tutorial-modal', 'warning-modal'].forEach(id => document.getElementById(id)?.classList.remove('is-open'));
                
                this.audioInit();
                this.renderGrid().then(() => {
                    if (!savedState) {
                        this.flashTwinningPattern();
                    }
                });
                this.renderScorePlaceholders();
                this.renderControls();
                this.updateAllScores();
                this.updateProgressBar();
                this.syncPanelHeights();
            }

            initializeHeroFeature() {
                this.heroSymbol = this.SYMBOLS[Math.floor(Math.random() * this.SYMBOLS.length)];
                this.heroBlocks = new Set();
                while (this.heroBlocks.size < 7) {
                    const r = Math.floor(Math.random() * this.GRID_SIZE);
                    const c = Math.floor(Math.random() * this.GRID_SIZE);
                    this.heroBlocks.add(`${r},${c}`);
                }
            }

            initTutorial() {
                if (localStorage.getItem('allohaTutorialCompleted')) return;
                
                this.tutorialMode = true;
                this.tutorialStep = 0;
                setTimeout(() => this.showTutorialStep(), 1000);
            }

            showTutorialStep() {
                const steps = [
                    {
                        title: "Welcome to Alloha!",
                        content: "Let's learn how to play. Click the dice button to roll your first pair!",
                    },
                    {
                        title: "Place Your Allohas",
                        content: "Click on an empty cell to place your first symbol, then an adjacent cell for the second.",
                    },
                    {
                        title: "Create Lines",
                        content: "Match 3 or more symbols in a row or column to score points!",
                    },
                    {
                        title: "Special Patterns",
                        content: "Highlighted cells give bonus points when you create lines through them!",
                    }
                ];

                if (this.tutorialStep >= steps.length) {
                    this.completeTutorial();
                    return;
                }

                const step = steps[this.tutorialStep];
                this.updateTutorialModal(step);
            }

            updateTutorialModal(step) {
                const modal = this.DOMElements.tutorial_modal;
                const content = this.DOMElements.tutorial_content;
                const nextBtn = this.DOMElements.tutorial_next_btn;
                const progressDots = modal.querySelectorAll('.tutorial-progress-dot');
                
                content.innerHTML = `<p class="text-lg">${step.content}</p>`;
                
                progressDots.forEach((dot, index) => {
                    dot.classList.toggle('active', index === this.tutorialStep);
                });
                
                nextBtn.textContent = this.tutorialStep === 3 ? "Start Playing" : "Next";
                
                modal.classList.add('is-open');
                document.body.classList.add('modal-open');
            }

            completeTutorial() {
                this.tutorialMode = false;
                localStorage.setItem('allohaTutorialCompleted', 'true');
                this.DOMElements.tutorial_modal.classList.remove('is-open');
                document.body.classList.remove('modal-open');
            }

            getState() {
                return {
                    gridData: JSON.stringify(this.gridData),
                    currentRoll: this.currentRoll,
                    firstPlacementCell: this.firstPlacementCell,
                    turnCount: this.turnCount,
                    stuckBlocks: [...this.stuckBlocks],
                    usedSuperpowers: [...this.usedSuperpowers],
                    lastGameState: this.lastGameState ? { ...this.lastGameState, gridData: JSON.stringify(this.lastGameState.gridData), stuckBlocks: new Set(this.lastGameState.stuckBlocks) } : null,
                    activeSuperpower: this.activeSuperpower,
                    currentTotalScore: this.currentTotalScore,
                    cursedBlockTurn: this.cursedBlockTurn,
                    wildcardTurn: this.wildcardTurn,
                    heroSymbol: this.heroSymbol,
                    heroBlocks: [...this.heroBlocks],
                    currentState: this.gameStateManager.currentState,
                    timeLeft: this.timeLeft,
                    isTimeBurst: this.isTimeBurst
                };
            }

            audioInit() { this.audioCreateContext(); this.audioCreateSounds(); }
            audioCreateContext() { try { if (!this.audio.context) this.audio.context = new (window.AudioContext || window.webkitAudioContext)(); } catch (e) {} }
            audioCreateSounds() { if (!this.audio.context || this.audio.sounds.size > 0) return; const s = { 'pop': [1200,.1,.05], 'roll': [220,.2,.2], 'hover': [660,.05,.1], 'invalid': [150,.3,.2], 'power-activate': [880,.15,.2], 'power-use': [1047,.2,.3], 'chime': [1047, .15, .2], 'thud': [100, .3, .1] }; for (const k in s) { this.audio.sounds.set(k, ()=>this.audioPlayTone(...s[k])); } }
            audioPlayTone(freq, vol, dur) { if (!this.audio.unlocked || !this.audio.context) return; try { const o = this.audio.context.createOscillator(), g = this.audio.context.createGain(); o.connect(g); g.connect(this.audio.context.destination); o.frequency.value = freq; g.gain.setValueAtTime(0, this.audio.context.currentTime); g.gain.linearRampToValueAtTime(vol*.1, this.audio.context.currentTime+.01); g.gain.exponentialRampToValueAtTime(.001, this.audio.context.currentTime+dur); o.start(); o.stop(this.audio.context.currentTime+dur); } catch (e) {} }
            audioUnlock() { if (this.audio.unlocked) return; document.getElementById('audio-unlocker').play().finally(() => { this.audio.unlocked = true; }); }
            audioPlay(soundName) { this.audio.sounds.get(soundName)?.(); }
            triggerVibration(duration = 10) { if (navigator.vibrate) { navigator.vibrate(duration); } }


            startTimer() {
                if (this.timerId || this.gameStateManager.is('GAME_OVER')) return;
                this.updateTimerDisplay();
                this.timerId = setInterval(() => {
                    if (this.gameStateManager.is('GAME_OVER')) {
                        this.stopTimer();
                        return;
                    }
                    this.timeLeft--;
                    this.updateTimerDisplay();
                    if (this.timeLeft <= 0) {
                        this.endGame("Time's up!");
                    }
                }, 1000);
            }

            stopTimer() {
                if (this.timerId) {
                    clearInterval(this.timerId);
                    this.timerId = null;
                }
            }

            updateTimerDisplay() {
                const timerEl = document.getElementById('timer-display');
                if (timerEl) {
                    timerEl.textContent = this.timeLeft;
                }
            }

            calculateLineScore(line, lineType, index) {
                let totalScore = 0; const usedIndices = new Set(); const scoredLines = [];
                for (let len = this.GRID_SIZE; len >= this.MIN_SEQUENCE_LENGTH; len--) {
                    for (let i = 0; i <= this.GRID_SIZE - len; i++) {
                        if ([...Array(len).keys()].some(k => usedIndices.has(i + k))) continue;
                        const slice = line.slice(i, i + len);
                        if (this.isValidSequence(slice)) {
                            const score = this.SCORING_RULES[len];
                            totalScore += score;
                            const cells = [];
                            for (let k = 0; k < len; k++) {
                                if (slice[k] !== this.SPECIAL_SYMBOLS.WILD) usedIndices.add(i + k);
                                cells.push(lineType === 'row' ? {r: index, c: i + k} : {r: i + k, c: index});
                            }
                            scoredLines.push({ score, cells });
                        }
                    }
                }
                if (totalScore === 0 && this.isLineDead(line)) return { total: this.LINE_DEATH_PENALTY, lines: [] };
                return { total: totalScore, lines: scoredLines };
            }

            isValidSequence(slice) {
                if (slice.some(s => s === null)) return false;
                if (!slice.some(s => s !== null)) return false;
                const regularSymbols = slice.filter(s => s && s !== this.SPECIAL_SYMBOLS.WILD);
                return new Set(regularSymbols).size <= 1;
            }

            isLineDead(line) {
                for (let i = 0; i <= line.length - this.MIN_SEQUENCE_LENGTH; i++) {
                    const window = line.slice(i, i + this.MIN_SEQUENCE_LENGTH);
                    if (window.includes(this.SPECIAL_SYMBOLS.CURSED)) {
                        continue;
                    }
                    const actualSymbols = window.filter(s => s && s !== this.SPECIAL_SYMBOLS.WILD && s !== this.SPECIAL_SYMBOLS.CURSED);
                    if (new Set(actualSymbols).size <= 1) {
                        return false; 
                    }
                }
                return true;
            }
            calculateBonusGrids() {
                let points = 0;
                for (let size = this.GRID_SIZE; size >= 2; size--) {
                    for (let r = 0; r <= this.GRID_SIZE - size; r++) {
                        for (let c = 0; c <= this.GRID_SIZE - size; c++) {
                            const first = this.gridData[r][c];
                            if (!first || first === this.SPECIAL_SYMBOLS.CURSED) continue;
                            const subgrid = Array(size).fill(0).map((_, i) => this.gridData[r+i].slice(c, c + size));
                            const flatSubgrid = subgrid.flat();
                            if (flatSubgrid.some(cell => !cell || cell === this.SPECIAL_SYMBOLS.CURSED)) continue;
                            const regularSymbols = flatSubgrid.filter(s => s !== this.SPECIAL_SYMBOLS.WILD);
                            if (new Set(regularSymbols).size <= 1) {
                                points += size * size;
                            }
                        }
                    }
                }
                return points;
            }
            createCellElement(r, c) { const cell = document.createElement('div'); cell.dataset.row = r; cell.dataset.col = c; cell.className = this.getCellClasses(r, c); return cell; }
            getCellClasses(r, c) {
                let classes = 'grid-cell';
                if (this.config.isTwinningCell(r, c)) classes += ' highlighted';
                if (this.stuckBlocks.has(`${r},${c}`)) classes += ' stuck-cell';
                if (this.heroBlocks.has(`${r},${c}`)) classes += ' hero-block-hint';
                return classes;
            }
            updateCell(cell, r, c) {
                cell.className = this.getCellClasses(r, c);
                const symbol = this.gridData[r][c];
                
                cell.innerHTML = ''; 
                cell.style.setProperty('--hero-symbol', `'${this.heroSymbol}'`);

                if (symbol) {
                    const symbolSpan = document.createElement('span');
                    symbolSpan.textContent = symbol;
                    if(this.SYMBOL_COLORS[symbol]) {
                       symbolSpan.className = this.SYMBOL_COLORS[symbol];
                    }
                    cell.appendChild(symbolSpan);
                } else {
                    cell.textContent = this.stuckBlocks.has(`${r},${c}`) ? '💣' : '';
                }
            }
            addCellEventListeners(cell) { cell.addEventListener('click', this.handleCellClick.bind(this)); }
            syncPanelHeights() { setTimeout(() => { if (window.innerWidth < 1024) return; const boardHeight = this.DOMElements.game_board_container?.getBoundingClientRect().height; if (boardHeight) this.DOMElements.scoring_panel.style.height = `${boardHeight}px`; }, 50); }
            
            updateProgressBar() {
                if (!this.DOMElements.progress_bar_fill) return;
                const percentage = (this.turnCount / this.MAX_TURNS) * 100;
                this.DOMElements.progress_bar_fill.style.width = `${percentage}%`;
            }

            flashTwinningPattern() {
                const highlightedCells = document.querySelectorAll('.highlighted');
                if (highlightedCells.length === 0) return;

                highlightedCells.forEach(cell => {
                    cell.classList.add('twinning-flash-animation');
                });
                setTimeout(() => {
                    highlightedCells.forEach(cell => {
                        cell.classList.remove('twinning-flash-animation');
                    });
                }, 1500);
            }

            async renderGrid() {
                const fragment = document.createDocumentFragment(); this.DOMElements.game_board.innerHTML = ''; this.gridCells = [];
                for (let r = 0; r < this.GRID_SIZE; r++) {
                    const row = [];
                    for (let c = 0; c < this.GRID_SIZE; c++) {
                        const cell = this.createCellElement(r, c); this.updateCell(cell, r, c); this.addCellEventListeners(cell);
                        fragment.appendChild(cell); row.push(cell);
                    }
                    this.gridCells.push(row);
                }
                this.DOMElements.game_board.appendChild(fragment);
            }
            updateFullGrid() { for (let r = 0; r < this.GRID_SIZE; r++) for (let c = 0; c < this.GRID_SIZE; c++) this.updateGridCell(r, c); }
            updateGridCell(r, c) { if (this.gridCells[r]?.[c]) this.updateCell(this.gridCells[r][c], r, c); }
            
            renderScorePlaceholders() {
                this.DOMElements.row_scores_display.innerHTML = ''; 
                this.DOMElements.col_scores_display.innerHTML = '';
                for (let i = 0; i < this.GRID_SIZE; i++) {
                    const rowScore = document.createElement('div'); rowScore.id = `row-score-${i}`; rowScore.className = 'grid-cell score-display-cell'; rowScore.textContent = '0'; this.DOMElements.row_scores_display.appendChild(rowScore);
                    const colScore = document.createElement('div'); colScore.id = `col-score-${i}`; colScore.className = 'grid-cell score-display-cell'; colScore.textContent = '0'; this.DOMElements.col_scores_display.appendChild(colScore);
                }
            }
            renderControls() {
                const inGameContent = this.DOMElements.in_game_content;
                const preGameContent = this.DOMElements.pre_game_content;
                
                if(inGameContent) inGameContent.className = '';

                if (this.gameStateManager.is('PRE_GAME')) {
                    if(preGameContent) preGameContent.style.display = 'block';
                    if(inGameContent) inGameContent.style.display = 'none';
                } else {
                    if(preGameContent) preGameContent.style.display = 'none';
                    if(inGameContent) inGameContent.style.display = 'block';
                    this.renderDiceAndPowers();
                }
            }
            renderDiceAndPowers() {
                const container = this.DOMElements.in_game_content;
                container.className = '';
                container.innerHTML = '';

                const wrapper = document.createElement('div');
                wrapper.className = 'w-full flex flex-col justify-start gap-3 lg:gap-4';
                let timerHTML = '';
                if(this.isTimeBurst) {
                    timerHTML = `<div id="timer-display" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card flex items-center justify-center text-2xl lg:text-3xl font-bold" style="color: var(--accent);">${this.timeLeft}</div>`;
                }

                wrapper.innerHTML = `<div class="flex justify-center items-center gap-2 lg:gap-4">
                    <button id="roll-dice-btn" aria-label="Roll Dice" class="w-14 h-14 lg:w-16 lg:h-16 text-4xl lg:text-5xl flex items-center justify-center" style="color: var(--accent);">🎲</button>
                    <div id="dice-1" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card flex items-center justify-center text-3xl lg:text-4xl shimmer-text">?</div>
                    <div id="dice-2" class="w-14 h-14 lg:w-16 lg:h-16 rounded-xl glass-card flex items-center justify-center text-3xl lg:text-4xl shimmer-text">?</div>
                    ${timerHTML}
                </div>
                <div class="glass-card rounded-xl px-3 py-4 text-center"><h2 class="text-sm font-semibold uppercase tracking-wider mb-3 flex items-center justify-center gap-2" style="color: var(--text-secondary);">Alloha Superpowers <span id="sp-charges" class="text-base">✨✨</span></h2><div class="grid grid-cols-4 gap-1 text-center">
                    <button id="past-lives-btn" class="superpower-btn"><div>Past</div><div>Lives</div><div class="superpower-used-overlay hidden absolute inset-0 text-red-500 text-4xl font-extrabold flex items-center justify-center" style="text-shadow: 0 1px 2px rgba(0,0,0,0.4);">X</div></button>
                    <button id="no-return-btn" class="superpower-btn"><div>No</div><div>Return</div><div class="superpower-used-overlay hidden absolute inset-0 text-red-500 text-4xl font-extrabold flex items-center justify-center" style="text-shadow: 0 1px 2px rgba(0,0,0,0.4);">X</div></button>
                    <button id="bomb-bae-btn" class="superpower-btn"><div>Bomb</div><div>Bae</div><div class="superpower-used-overlay hidden absolute inset-0 text-red-500 text-4xl font-extrabold flex items-center justify-center" style="text-shadow: 0 1px 2px rgba(0,0,0,0.4);">X</div></button>
                    <button id="swap-them-btn" class="superpower-btn"><div>Swap</div><div>Them</div><div class="superpower-used-overlay hidden absolute inset-0 text-red-500 text-4xl font-extrabold flex items-center justify-center" style="text-shadow: 0 1px 2px rgba(0,0,0,0.4);">X</div></button>
                </div></div>`;
                
                const rollBtn = wrapper.querySelector('#roll-dice-btn');
                rollBtn.onclick = this.handleRollDice.bind(this);
                if(this.gameStateManager.is('AWAITING_ROLL')) {
                    rollBtn.classList.add('bob-animation');
                }

                this.DOMElements.in_game_content.innerHTML = '';
                this.DOMElements.in_game_content.appendChild(wrapper);
                this.updateControlsState();
                this.setupSuperpowerEventListeners(); 
                this.updateSuperpowerButtonsUI();
                if(this.isTimeBurst) this.updateTimerDisplay();
            }
            updateControlsState() {
                if (this.gameStateManager.is('PRE_GAME')) return;
                const rollBtn = document.getElementById('roll-dice-btn');
                if (rollBtn) {
                    rollBtn.disabled = !this.gameStateManager.is('AWAITING_ROLL');
                    rollBtn.classList.toggle('bob-animation', this.gameStateManager.is('AWAITING_ROLL'));
                }
                const dice1 = document.getElementById('dice-1'), dice2 = document.getElementById('dice-2');
                if (!dice1 || !dice2) return;
                
                dice1.classList.remove('shimmer-text');
                dice2.classList.remove('shimmer-text');
                
                if (this.gameStateManager.is('AWAITING_PLACEMENT') && this.currentRoll.length === 2) {
                    const symbol1 = this.currentRoll[0], symbol2 = this.currentRoll[1];
                    const color1 = this.SYMBOL_COLORS[symbol1] || 'text-gray-700';
                    const color2 = this.SYMBOL_COLORS[symbol2] || 'text-gray-700';

                    dice1.innerHTML = `<span class="${color1}">${symbol1}</span>`;
                    dice2.innerHTML = `<span class="${color2}">${symbol2}</span>`;
                } else {
                    dice1.textContent = '?';
                    dice2.textContent = '?';
                    dice1.classList.add('shimmer-text');
                    dice2.classList.add('shimmer-text');
                }
            }
            async handleRollDice() {
                if (!this.gameStateManager.is('AWAITING_ROLL')) return;
                this.triggerVibration(50);

                if (this.turnCount >= this.MAX_TURNS || !this.hasValidMoves()) {
                    this.startGoldenAllohaSequence();
                    return;
                }

                this.gameStateManager.setState('ANIMATING_ROLL');
                if (this.isTimeBurst && !this.timerId) { this.startTimer(); }

                const d1 = document.getElementById('dice-1'), d2 = document.getElementById('dice-2');
                this.updateControlsState();
                d1.classList.add('dice-tumble');
                d2.classList.add('dice-tumble');

                const nextTurn = this.turnCount + 1; let tempRoll;
                if (nextTurn === this.cursedBlockTurn) { this.audioPlay('thud'); tempRoll = [this.SYMBOLS[Math.floor(Math.random() * this.SYMBOLS.length)], this.SPECIAL_SYMBOLS.CURSED]; }
                else if (nextTurn === this.wildcardTurn) { this.audioPlay('chime'); tempRoll = [this.SYMBOLS[Math.floor(Math.random() * this.SYMBOLS.length)], this.SPECIAL_SYMBOLS.WILD]; }
                else { this.audioPlay('roll'); tempRoll = [this.SYMBOLS[Math.floor(Math.random() * this.SYMBOLS.length)], this.SYMBOLS[Math.floor(Math.random() * this.SYMBOLS.length)]]; }
                
                this.currentRoll = tempRoll.sort(() => Math.random() - 0.5);
                
                await delay(600);
                                
                this.gameStateManager.setState('AWAITING_PLACEMENT');
                this.saveStateForUndo(); 
                this.updateControlsState(); 
                this.updateSuperpowerButtonsUI();
            }
            handleCellClick(e) {
                const cell = e.target.closest('[data-row]'); if (!cell) return;
                const r = parseInt(cell.dataset.row), c = parseInt(cell.dataset.col);

                if (this.activeSuperpower) { this.handleSuperpowerCellClick(r, c, cell); return; }
                if (!this.gameStateManager.is('AWAITING_PLACEMENT')) return;
                if (this.firstPlacementCell) { this.handleSecondPlacement(r, c, cell); } else { this.handleFirstPlacement(r, c); }
            }
            handleFirstPlacement(r, c) { 
                if (!this.gridData[r][c]) { 
                    this.gridData[r][c] = this.currentRoll[0]; 
                    this.firstPlacementCell = { r, c }; 
                    this.updateGridCell(r, c); 
                    this.highlightValidPlacements(r, c);
                    this.updateSuperpowerButtonsUI(); 
                } 
            }
            handleSecondPlacement(r, c, cell) {
                const { r: pR, c: pC } = this.firstPlacementCell;
                if (pR === r && pC === c) { 
                    this.gridData[r][c] = null; 
                    this.firstPlacementCell = null; 
                    this.updateGridCell(r, c); 
                    this.clearPlacementHighlights();
                    this.updateSuperpowerButtonsUI(); 
                    return; 
                }
                if ((Math.abs(pR - r) + Math.abs(pC - c) === 1) && !this.gridData[r][c]) { 
                    this.clearPlacementHighlights();
                    this.completeMove(r, c); 
                }
                else { 
                    cell.classList.add('shake-animation'); 
                    setTimeout(() => cell.classList.remove('shake-animation'), 400); 
                    this.audioPlay('invalid'); 
                }
            }
            saveStateForUndo() { this.lastGameState = this.getState(); }
            async completeMove(r, c) {
                this.gameStateManager.setState('PROCESSING_TURN');
                const firstCellCoords = this.firstPlacementCell; 
                this.gridData[r][c] = this.currentRoll[1];
                this.lastMoveCoords = [{r,c}, firstCellCoords];
                this.firstPlacementCell = null;
                this.turnCount++;
                this.updateProgressBar();
                this.updateGridCell(r, c);
                this.audioPlay('pop');
                this.triggerVibration(20);
                
                await delay(300);
                this.processTurnEnd();
            }

            processTurnEnd() {
                if (this.gameStateManager.is('GAME_OVER')) return;
                this.updateAllScores(); 
                if (this.turnCount >= this.MAX_TURNS || !this.hasValidMoves()) {
                    this.gameStateManager.setState('AWAITING_ROLL');
                    this.renderControls();
                    return;
                }
                this.gameStateManager.setState('AWAITING_ROLL');
                this.renderControls();
            }

            highlightValidPlacements(r, c) {
                const adjacent = [ [r-1, c], [r+1, c], [r, c-1], [r, c+1] ];
                adjacent.forEach(([nr, nc]) => {
                    if (nr >= 0 && nr < this.GRID_SIZE && nc >= 0 && nc < this.GRID_SIZE && !this.gridData[nr][nc]) {
                        const cell = this.gridCells[nr][nc];
                        cell.classList.add('valid-placement');
                    }
                });
            }

            clearPlacementHighlights() {
                this.gridCells.flat().forEach(cell => {
                    cell.classList.remove('valid-placement');
                });
            }

            async renderGoldenAllohaSelector() {
                return new Promise(resolve => {
                    const container = this.DOMElements.in_game_content;
                    container.innerHTML = '';

                    const wrapper = document.createElement('div');
                    wrapper.className = 'w-full flex flex-col items-center justify-center h-full gap-4 pt-2';
                    
                    const title = document.createElement('h2');
                    title.className = 'text-base lg:text-lg font-semibold text-center uppercase tracking-wider';
                    title.style.color = 'var(--accent)';
                    title.textContent = 'Choose One Last Alloha';

                    const selector = document.createElement('div');
                    selector.className = 'grid grid-cols-3 gap-2 lg:gap-4';

                    this.SYMBOLS.forEach(symbol => {
                        const btn = document.createElement('button');
                        btn.className = `w-12 h-12 lg:w-14 lg:h-14 rounded-xl text-3xl flex items-center justify-center transition-transform hover:scale-110 active:scale-95`;
                        const symbolSpan = document.createElement('span');
                        symbolSpan.className = this.SYMBOL_COLORS[symbol] || '';
                        symbolSpan.textContent = symbol;
                        btn.appendChild(symbolSpan);
                        btn.onclick = () => resolve(symbol);
                        selector.appendChild(btn);
                    });

                    wrapper.appendChild(title);
                    wrapper.appendChild(selector);
                    container.appendChild(wrapper);
                });
            }

            renderGoldenAllohaPlacementPrompt(symbol) {
                const container = this.DOMElements.in_game_content;
                container.innerHTML = '';
                container.className = 'w-full flex flex-col items-center justify-center h-full text-center p-4';

                const line1 = document.createElement('h2');
                line1.className = 'text-xl lg:text-2xl font-semibold';
                line1.style.color = 'var(--accent)';
                line1.innerHTML = `You chose <span class="text-5xl align-middle ${this.SYMBOL_COLORS[symbol] || 'text-gray-700'}">${symbol}</span>`;

                const line2 = document.createElement('p');
                line2.className = 'text-base lg:text-lg font-medium mt-2';
                line2.style.color = 'var(--text-secondary)';
                line2.textContent = 'Place it on any highlighted Allohome!';

                container.appendChild(line1);
                container.appendChild(line2);
            }

            renderEndGamePanel(score) {
                const container = this.DOMElements.in_game_content;
                container.innerHTML = '';
                container.className = 'w-full flex flex-col items-center justify-center h-full text-center p-4';

                const title = document.createElement('h2');
                title.className = 'text-3xl font-bold';
                title.style.fontFamily = "'Pacifico', cursive";
                title.style.color = 'var(--accent)';
                title.textContent = 'Game Over Alloha!';

                const scoreDisplay = document.createElement('div');
                scoreDisplay.id = 'end-game-score-display'; 
                scoreDisplay.className = 'text-7xl font-bold my-2';
                scoreDisplay.style.color = 'var(--accent)';
                
                container.appendChild(title);
                container.appendChild(scoreDisplay);
                animateScoreUpdate('end-game-score-display', score, 3);
            }

            // -- FIX 3: Robust Event Listener handling --
            async waitForCellClick(validCells) {
                const board = this.DOMElements.game_board;
                let clickHandler;
                try {
                    return await new Promise(resolve => {
                        clickHandler = (e) => {
                            const cellEl = e.target.closest('[data-row]');
                            if (!cellEl) return;
                            const r = parseInt(cellEl.dataset.row);
                            const c = parseInt(cellEl.dataset.col);

                            if (validCells.some(cell => cell.r === r && cell.c === c)) {
                                resolve({ r, c });
                            }
                        };
                        board.addEventListener('click', clickHandler);
                    });
                } finally {
                    // This block ensures the listener is always removed once the promise resolves.
                    if (clickHandler) {
                        board.removeEventListener('click', clickHandler);
                    }
                }
            }

            async startGoldenAllohaSequence() {
                this.gameStateManager.setState('AWAITING_GOLDEN_PLACEMENT');

                const emptyCells = [];
                for (let r = 0; r < this.GRID_SIZE; r++) {
                    for (let c = 0; c < this.GRID_SIZE; c++) {
                        if (!this.gridData[r][c]) emptyCells.push({ r, c });
                    }
                }

                if (emptyCells.length === 0) {
                    this.endGame("Grid is full!");
                    return;
                }
                
                const chosenSymbol = await this.renderGoldenAllohaSelector();
                this.renderGoldenAllohaPlacementPrompt(chosenSymbol);
                
                emptyCells.forEach(({ r, c }) => {
                    if (this.gridCells[r] && this.gridCells[r][c]) {
                        this.gridCells[r][c].classList.add('golden-placement-option');
                    }
                });
                
                const targetCell = await this.waitForCellClick(emptyCells);
                
                emptyCells.forEach(({ r, c }) => {
                    if (this.gridCells[r] && this.gridCells[r][c]) {
                        this.gridCells[r][c].classList.remove('golden-placement-option');
                    }
                });

                this.gridData[targetCell.r][targetCell.c] = chosenSymbol;
                this.updateGridCell(targetCell.r, targetCell.c);
                this.audioPlay('chime');
                this.triggerVibration(20);

                emptyCells.forEach(({ r, c }) => {
                    if (r !== targetCell.r || c !== targetCell.c) {
                        this.stuckBlocks.add(`${r},${c}`);
                        this.updateGridCell(r, c);
                    }
                });

                if (emptyCells.length > 1) this.audioPlay('thud');

                await delay(500); 

                this.endGame("The grid is complete!");
            }
            
            endGame(reason = "") {
                if (this.gameStateManager.is('GAME_OVER')) return;
                this.stopTimer();
                this.gameStateManager.setState('GAME_OVER');
                this.lastMoveCoords = null;
                this.updateAllScores();

                if (reason === "Time's up!") {
                    this.DOMElements.game_board_container.classList.add('shake-animation');
                    setTimeout(() => this.DOMElements.game_board_container.classList.remove('shake-animation'), 500);
                }
                
                let finalScore = this.currentTotalScore;
                
                const isGridIncomplete = this.gridData.flat().includes(null);
                if (reason === "Time's up!" && isGridIncomplete) {
                    finalScore = 0;
                }

                this.renderEndGamePanel(finalScore);

                const highScoreKey = `cactiFactiHighScore_${this.config.id}_${this.isTimeBurst ? 'timeburst' : 'classic'}`;
                const currentHighScore = parseInt(localStorage.getItem(highScoreKey)) || 0;
                if (finalScore > currentHighScore) {
                    localStorage.setItem(highScoreKey, finalScore);
                    this.highScore = finalScore;
                    this.triggerConfetti();
                }

                this.DOMElements.game_over_reason.textContent = reason;
                animateScoreUpdate('final-score-modal', finalScore, 3);
                animateScoreUpdate('high-score-modal', this.highScore, 3);
                
                const formatNegative = (val, len = 2) => val < 0 ? `(${String(Math.abs(val)).padStart(len,'0')})` : String(val).padStart(len,'0');
                this.DOMElements.final_rows_score.textContent = formatNegative(this.scores.rows);
                this.DOMElements.final_cols_score.textContent = formatNegative(this.scores.cols);
                this.DOMElements.final_cross_score.textContent = formatNegative(this.scores.cross);
                this.DOMElements.final_bonus_score.textContent = formatNegative(this.scores.bonus);
                this.DOMElements.final_hero_score.textContent = formatNegative(this.scores.hero);
                this.DOMElements.final_penalty_score.textContent = formatNegative(this.scores.penalty);

                setTimeout(() => {
                    this.DOMElements.game_over_modal.classList.add('is-open');
                    document.body.classList.add('modal-open');
                    const shareBtn = document.getElementById('share-score-btn');
                    if (shareBtn) {
                        shareBtn.onclick = () => this.handleShareScore(finalScore, this.highScore);
                    }
                    const changeEditionBtn = document.getElementById('change-edition-btn-modal');
                    if (changeEditionBtn) {
                        changeEditionBtn.onclick = () => {
                            this.DOMElements.game_over_modal.classList.remove('is-open');
                            document.body.classList.remove('modal-open');
                            document.getElementById('select-edition-btn').click();
                        };
                    }
                }, 500);
            }

            async handleShareScore(score, highScore) {
                const shareBtn = document.getElementById('share-score-btn');
                const shareBtnSpan = shareBtn.querySelector('span');
                if (!shareBtn || !shareBtnSpan) return;

                const originalBtnContent = shareBtn.innerHTML;

                const finalScoreEl = document.getElementById('final-score-modal');
                const highScoreEl = document.getElementById('high-score-modal');
                const originalFinalScoreHTML = finalScoreEl.innerHTML;
                const originalHighScoreHTML = highScoreEl.innerHTML;

                try {
                    shareBtnSpan.textContent = 'Generating...';
                    shareBtn.disabled = true;

                    // Temporarily replace animated scores with static text for canvas rendering
                    finalScoreEl.classList.remove('digit-score-container');
                    finalScoreEl.innerHTML = `${score}`;
                    highScoreEl.classList.remove('digit-score-container');
                    highScoreEl.innerHTML = `${highScore}`;

                    const scoreBreakdown = document.getElementById('score-breakdown');
                    const buttonContainer = document.getElementById('game-over-buttons');
                    const modalContent = document.querySelector('#game-over-modal .modal-content');
                    
                    const editionName = this.config.name;
                    const shareHeader = document.createElement('div');
                    shareHeader.innerHTML = `<p style="margin-bottom: 0.5rem; font-family: 'Quicksand', sans-serif; font-weight: 600; color: var(--text-secondary);">${editionName}</p>`;
                    const shareFooter = document.createElement('div');
                    shareFooter.innerHTML = `<p style="margin-top: 1rem; font-family: 'Quicksand', sans-serif; font-weight: 700; color: var(--accent);">Play Alloha!</p>`;

                    modalContent.prepend(shareHeader);
                    modalContent.appendChild(shareFooter);

                    if (scoreBreakdown) scoreBreakdown.style.display = 'none';
                    if (buttonContainer) buttonContainer.style.display = 'none';

                    await new Promise(resolve => setTimeout(resolve, 50));

                    const canvas = await html2canvas(modalContent, {
                        allowTaint: true,
                        useCORS: true,
                        backgroundColor: null,
                        ignoreElements: (element) => element.classList.contains('no-screenshot')
                    });

                    shareHeader.remove();
                    shareFooter.remove();

                    if (scoreBreakdown) scoreBreakdown.style.display = 'grid';
                    if (buttonContainer) buttonContainer.style.display = 'flex';

                    const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                    if (!blob) throw new Error("Canvas to Blob conversion failed.");
                    
                    const file = new File([blob], 'alloha-score.png', { type: 'image/png' });
                    const shareText = `✨ I scored ${score} in Alloha! ✨\n\nThink you can beat my score in Alloha? 🎲\n\nPlay now: https://abhimanyulodha.github.io/alloha/`;

                    if (navigator.share && navigator.canShare({ files: [file] })) {
                        await navigator.share({
                            title: 'My Alloha Score!',
                            text: shareText,
                            files: [file]
                        });
                    } else {
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = 'Alloha-Score.png';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(link.href);
                    }
                } catch (error) {
                    console.error('Sharing failed:', error);
                    shareBtnSpan.textContent = 'Error!';
                } finally {
                    // Restore the original animated score display
                    finalScoreEl.innerHTML = originalFinalScoreHTML;
                    highScoreEl.innerHTML = originalHighScoreHTML;

                    setTimeout(() => {
                        shareBtn.innerHTML = originalBtnContent;
                        shareBtn.disabled = false;
                    }, 2000);
                }
            }

            triggerConfetti() {
                const container = this.DOMElements.effects_container;
                if (!container) return;
                const colors = ['#E57373', '#FF8A65', '#FFC107', '#FFF176'];
                for (let i = 0; i < 50; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti-piece';
                    confetti.style.left = `${Math.random() * 100}%`;
                    confetti.style.animation = `confetti-fall ${1.5 + Math.random() * 2}s ${Math.random() * 2}s linear forwards`;
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    container.appendChild(confetti);
                    setTimeout(() => confetti.remove(), 4000);
                }
            }

            hasValidMoves() { for (let r = 0; r < this.GRID_SIZE; r++) for (let c = 0; c < this.GRID_SIZE; c++) if (!this.gridData[r][c]) { const n = [[-1, 0], [1, 0], [0, -1], [0, 1]]; for (const [dr, dc] of n) { const nr = r + dr, nc = c + dc; if (nr >= 0 && nr < this.GRID_SIZE && nc >= 0 && nc < this.GRID_SIZE && !this.gridData[nr][nc]) return true; } } return false; }
            detectStuckBlocks() { this.stuckBlocks.clear(); for (let r = 0; r < this.GRID_SIZE; r++) for (let c = 0; c < this.GRID_SIZE; c++) if (!this.gridData[r][c]) { const n = [[-1, 0], [1, 0], [0, -1], [0, 1]]; if (n.every(([dr, dc]) => { const nr = r + dr, nc = c + dc; return nr < 0 || nr >= this.GRID_SIZE || nc < 0 || nc >= this.GRID_SIZE || this.gridData[nr][nc] })) this.stuckBlocks.add(`${r},${c}`); } this.updateFullGrid(); }
            updateAllScores() {
                const rS = this.calculateRowScores(), cS = this.calculateColumnScores(), crS = this.calculateCrossScore(), bS = this.calculateBonusGrids(), hS = this.calculateHeroBonus();
                
                this.triggerBoardAndFloatAnimations(rS.lines, this.lastMoveCoords);
                this.triggerBoardAndFloatAnimations(cS.lines, this.lastMoveCoords);
                
                this.scores = { rows: rS.total, cols: cS.total, cross: crS, bonus: bS, hero: hS, penalty: -this.stuckBlocks.size };
                this.currentTotalScore = rS.total + cS.total + crS + bS + hS - this.stuckBlocks.size;

                this.updateScoreDisplays(this.scores.rows, this.scores.cols, this.scores.cross, this.scores.bonus, this.scores.hero, this.scores.penalty);
                this.updateIndividualScores(rS.individual, cS.individual);
            }

            calculateHeroBonus() {
                let heroScore = 0;
                if(this.lastMoveCoords) {
                    this.lastMoveCoords.forEach(coord => {
                        if (this.heroBlocks.has(`${coord.r},${coord.c}`) && this.gridData[coord.r][coord.c] === this.heroSymbol) {
                            heroScore += 2;
                            this.heroBlocks.delete(`${coord.r},${coord.c}`); // Remove to prevent re-scoring
                            showFloatingScore('+2', this.gridCells[coord.r][coord.c]);
                        }
                    });
                }
                return this.scores.hero + heroScore;
            }

            calculateRowScores() { 
                let total = 0, individual = [], allScoredLines = [];
                for (let i = 0; i < this.GRID_SIZE; i++) {
                    const result = this.calculateLineScore(this.gridData[i], 'row', i);
                    individual.push(result.total);
                    total += result.total;
                    allScoredLines.push(...result.lines);
                }
                return { total, individual, lines: allScoredLines };
            }
            calculateColumnScores() {
                let total = 0, individual = [], allScoredLines = [];
                for (let i = 0; i < this.GRID_SIZE; i++) {
                    const col = this.gridData.map(row => row[i]);
                    const result = this.calculateLineScore(col, 'col', i);
                    individual.push(result.total);
                    total += result.total;
                    allScoredLines.push(...result.lines);
                }
                return { total, individual, lines: allScoredLines };
            }

            triggerBoardAndFloatAnimations(scoredLines, lastMoveCoords) {
                if (!scoredLines || !lastMoveCoords) return;
                const lastMoveSet = new Set(lastMoveCoords.map(c => `${c.r},${c.c}`));

                scoredLines.forEach(line => {
                    const isNewlyFormed = line.cells.some(cell => lastMoveSet.has(`${cell.r},${cell.c}`));
                    if (line.score > 0 && isNewlyFormed) {
                        const sourceCell = this.gridCells[line.cells[Math.floor(line.cells.length / 2)].r][line.cells[Math.floor(line.cells.length / 2)].c];
                        showFloatingScore(`+${line.score}`, sourceCell);
                        line.cells.forEach(coord => {
                            const cellEl = this.gridCells[coord.r][coord.c];
                            cellEl.classList.add('score-pulse-animation');
                            cellEl.addEventListener('animationend', () => cellEl.classList.remove('score-pulse-animation'), { once: true });
                        });
                    }
                });
            }

            calculateCrossScore() {
                let bonusScore = 0;
                const getScoreForSegment = (segmentSymbols) => {
                    if (segmentSymbols.length < this.MIN_SEQUENCE_LENGTH) return 0;
                    let score = 0; const usedIndices = new Set();
                    for (let len = segmentSymbols.length; len >= this.MIN_SEQUENCE_LENGTH; len--) {
                         for (let i = 0; i <= segmentSymbols.length - len; i++) {
                            if ([...Array(len).keys()].some(k => usedIndices.has(i + k))) continue;
                            const slice = segmentSymbols.slice(i, i + len);
                            if (this.isValidSequence(slice)) {
                                score += this.SCORING_RULES[len] || 0;
                                for (let k = 0; k < len; k++) if (slice[k] !== this.SPECIAL_SYMBOLS.WILD) usedIndices.add(i + k);
                            }
                        }
                    }
                    if (score > 0) return score;
                    if (this.isLineDead(segmentSymbols)) return this.CROSS_DEATH_PENALTY;
                    return 0;
                };

                this.config.getCrossScoreSegments().forEach(seg => {
                    const segmentSymbols = [];
                    for (let i = seg.start; i <= seg.end; i++) {
                        segmentSymbols.push(seg.type === 'row' ? this.gridData[seg.index][i] : this.gridData[i][seg.index]);
                    }
                    bonusScore += getScoreForSegment(segmentSymbols);
                });

                if (this.config.id === 'zedi_zodi') {
                    const diagonal = [];
                    for (let i = 0; i < this.GRID_SIZE; i++) {
                        diagonal.push(this.gridData[i][this.GRID_SIZE - 1 - i]);
                    }
                    bonusScore += getScoreForSegment(diagonal);
                }

                return bonusScore;
            }

            updateScoreDisplays(r, c, cross, b, h, p) { 
                animateScoreUpdate('total-score', r + c + cross + b + h + p, 3); 
                animateScoreUpdate('rows-total-score', r, 2); 
                animateScoreUpdate('cols-total-score', c, 2); 
                animateScoreUpdate('cross-total-score', cross, 2); 
                animateScoreUpdate('bonus-grid-score', b, 2);
                animateScoreUpdate('hero-bonus-score', h, 2);
                animateScoreUpdate('empty-block-penalty', p, 2); 
            }
            
            updateIndividualScores(rS, cS) { 
                rS.forEach((s, i) => this.updateScoreElement(`row-score-${i}`, s)); 
                cS.forEach((s, i) => this.updateScoreElement(`col-score-${i}`, s)); 
            }
            updateScoreElement(id, score) { const el = document.getElementById(id); if (el) { el.textContent = score; el.classList.toggle('text-red-500', score < 0); } }
            
            updateSuperpowerButtonsUI() {
                const ids = ['past-lives', 'no-return', 'bomb-bae', 'swap-them'];
                ids.forEach(id => {
                    const btn = document.getElementById(`${id}-btn`);
                    if (!btn) return;
                    const overlay = btn.querySelector('.superpower-used-overlay');
                    const camelCaseKey = id.replace(/-./g, char => char.toUpperCase()[1]);
                    if(this.usedSuperpowers.has(camelCaseKey)) {
                        if(overlay) overlay.classList.remove('hidden');
                    } else {
                        if(overlay) overlay.classList.add('hidden');
                    }
                });

                const totalUsed = this.usedSuperpowers.size, isMidMove = this.firstPlacementCell !== null, isPowerActive = this.activeSuperpower !== null, isAwaitingRoll = this.gameStateManager.is('AWAITING_ROLL');
                const btns = { pastLives: document.getElementById('past-lives-btn'), bombBae: document.getElementById('bomb-bae-btn'), noReturn: document.getElementById('no-return-btn'), swapThem: document.getElementById('swap-them-btn') };
                
                if (btns.pastLives) btns.pastLives.disabled = totalUsed >= 2 || this.usedSuperpowers.has('pastLives') || !this.lastGameState || isMidMove || isPowerActive || !isAwaitingRoll;
                if (btns.bombBae) btns.bombBae.disabled = totalUsed >= 2 || this.usedSuperpowers.has('bombBae') || this.stuckBlocks.size === 0 || isMidMove || isPowerActive;
                if (btns.noReturn) btns.noReturn.disabled = this.turnCount < 1 || totalUsed >= 2 || this.usedSuperpowers.has('noReturn') || isMidMove || isPowerActive;
                if (btns.swapThem) btns.swapThem.disabled = this.turnCount < 1 || totalUsed >= 2 || this.usedSuperpowers.has('swapThem') || !isAwaitingRoll || isMidMove || isPowerActive;
                
                Object.values(btns).forEach(btn => { if(btn) btn.classList.remove('superpower-btn--active')});
                if (isPowerActive && btns[this.activeSuperpower]) {
                    btns[this.activeSuperpower].classList.add('superpower-btn--active');
                }
                document.body.classList.toggle('cursor-target', this.activeSuperpower === 'bombBae');

                const spChargesEl = document.getElementById('sp-charges');
                if (spChargesEl) {
                    if (totalUsed === 0) {
                        spChargesEl.innerHTML = '✨✨';
                    } else if (totalUsed === 1) {
                        spChargesEl.innerHTML = '✨<span class="opacity-30">✨</span>';
                    } else {
                        spChargesEl.innerHTML = '<span class="opacity-30">✨✨</span>';
                    }
                }
            }
            handleSuperpowerCellClick(r, c, cell) {
                if (this.activeSuperpower === 'swapThem') {
                    if (!this.gridData[r][c] || this.gridData[r][c] === this.SPECIAL_SYMBOLS.CURSED) { this.audioPlay('invalid'); return; }
                    if (!this.swapFirstCell) { this.swapFirstCell = { r, c }; cell.classList.add('pulse-animation'); }
                    else {
                        const { r: r1, c: c1 } = this.swapFirstCell;
                        if (r1 === r && c1 === c) { this.swapFirstCell = null; cell.classList.remove('pulse-animation'); return; }
                        if (Math.abs(r1 - r) + Math.abs(c1 - c) === 1) {
                            [this.gridData[r1][c1], this.gridData[r][c]] = [this.gridData[r][c], this.gridData[r1][c1]];
                            this.gridCells[r1][c1].classList.remove('pulse-animation'); this.swapFirstCell = null;
                            this.consumeSuperpower('swapThem'); this.gameStateManager.setState('AWAITING_ROLL'); this.renderControls();
                        } else { this.audioPlay('invalid'); cell.classList.add('shake-animation'); setTimeout(() => cell.classList.remove('shake-animation'), 400); this.gridCells[r1][c1].classList.remove('pulse-animation'); this.swapFirstCell = null; }
                    } return;
                }
                if (this.gridData[r][c] === this.SPECIAL_SYMBOLS.CURSED) { this.audioPlay('invalid'); cell.classList.add('shake-animation'); setTimeout(() => cell.classList.remove('shake-animation'), 400); return; }
                if (this.activeSuperpower === 'bombBae' && this.stuckBlocks.has(`${r},${c}`)) { this.stuckBlocks.delete(`${r},${c}`); this.gridData[r][c] = this.SYMBOLS[Math.floor(Math.random() * this.SYMBOLS.length)]; this.consumeSuperpower('bombBae'); this.gameStateManager.setState('AWAITING_ROLL'); this.renderControls(); }
                else if (this.activeSuperpower === 'noReturn' && this.gridData[r][c]) { this.showSymbolSelectorForExchange(r, c); }
                else { this.audioPlay('invalid'); }
            }
            showSymbolSelectorForExchange(r, c) {
                 this.cellToExchange = {r, c}; this.DOMElements.exchange_options.innerHTML = '';
                 this.SYMBOLS.filter(s => s !== this.gridData[r][c]).forEach(symbol => {
                    const btn = document.createElement('button');
                    btn.className = `w-20 h-20 text-4xl rounded-lg hover:bg-orange-100/50 flex items-center justify-center`;
                    const symbolSpan = document.createElement('span');
                    symbolSpan.className = this.SYMBOL_COLORS[symbol] || '';
                    symbolSpan.textContent = symbol;
                    btn.appendChild(symbolSpan);
                    btn.onclick = () => this.handleSymbolExchange(symbol); this.DOMElements.exchange_options.appendChild(btn);
                 });
                 this.DOMElements.exchange_modal.classList.add('is-open');
                 document.body.classList.add('modal-open');
            }
            handleSymbolExchange(newSymbol) {
                if (!this.cellToExchange) return;
                const {r, c} = this.cellToExchange; this.gridData[r][c] = newSymbol;
                this.DOMElements.exchange_modal.classList.remove('is-open'); 
                document.body.classList.remove('modal-open');
                this.cellToExchange = null;
                this.consumeSuperpower('noReturn'); this.gameStateManager.setState('AWAITING_ROLL'); this.renderControls();
            }
            consumeSuperpower(powerName) {
                this.triggerVibration(30);
                this.audioPlay('power-use'); this.usedSuperpowers.add(powerName); this.activeSuperpower = null;
                this.updateFullGrid(); this.updateAllScores(); this.updateSuperpowerButtonsUI();
            }
            setupSuperpowerEventListeners() {
                document.getElementById('past-lives-btn')?.addEventListener('click', () => {
                    if (document.getElementById('past-lives-btn').disabled) return;
                    this.audioPlay('power-activate');
                    this.triggerVibration(30);

                    const state = this.lastGameState;
                    this.gridData = JSON.parse(state.gridData);
                    this.currentRoll = state.currentRoll;
                    this.firstPlacementCell = state.firstPlacementCell;
                    this.turnCount = state.turnCount;
                    this.stuckBlocks = new Set(state.stuckBlocks);
                    this.gameStateManager.currentState = state.currentState;
                    this.timeLeft = state.timeLeft;

                    this.updateFullGrid();
                    this.updateControlsState();
                    this.updateAllScores();
                    this.updateProgressBar();
                    
                    this.consumeSuperpower('pastLives');
                });
                const powerBtns = { bombBae: 'bomb-bae-btn', noReturn: 'no-return-btn', swapThem: 'swap-them-btn' };
                for (const [power, id] of Object.entries(powerBtns)) { document.getElementById(id)?.addEventListener('click', () => { if (document.getElementById(id).disabled) return; this.activeSuperpower = power; this.gameStateManager.setState('SUPERPOWER_ACTIVE'); this.audioPlay('power-activate'); this.triggerVibration(30); this.updateSuperpowerButtonsUI(); }); }
            }
            setupEventListeners() {
                this.DOMElements.close_rules_btn.addEventListener('click', () => { this.DOMElements.rules_modal.classList.remove('is-open'); document.body.classList.remove('modal-open'); });
                this.DOMElements.close_game_over_btn.addEventListener('click', () => { this.DOMElements.game_over_modal.classList.remove('is-open'); document.body.classList.remove('modal-open'); });
                this.DOMElements.play_again_btn.addEventListener('click', () => { this.DOMElements.game_over_modal.classList.remove('is-open'); document.body.classList.remove('modal-open'); gameManager.resetCurrentVariant(); });
                
                this.DOMElements.close_tutorial_btn.addEventListener('click', () => {
                    this.completeTutorial();
                });
                
                this.DOMElements.tutorial_next_btn.addEventListener('click', () => {
                    this.tutorialStep++;
                    this.showTutorialStep();
                });
                
                window.addEventListener('resize', this.syncPanelHeights.bind(this));
            }
        }
        
        // --- GAME MANAGER ---
        const gameManager = {
            gameStates: {},
            activeVariantId: null,
            currentGameInstance: null,
            pendingAction: null,
            activeMode: 'classic',

            init() {
                this.populateEditionModal();
                this.setupGlobalEventListeners();
                this.switchVariant('plain_jean', false);
            },

            populateEditionModal() {
                const container = document.getElementById('edition-options');
                container.innerHTML = '';
                Object.values(variantConfigs).forEach(config => {
                    const button = document.createElement('button');
                    button.className = 'w-full text-left p-3 rounded-lg hover:bg-gray-200/50 font-semibold transition-colors';
                    button.textContent = config.name;
                    button.dataset.editionId = config.id; 
                    button.onclick = () => {
                        const game = this.currentGameInstance;
                        const isGameInProgress = game && game.turnCount > 0 && !game.gameStateManager.is('GAME_OVER');
                        
                        document.getElementById('edition-select-modal').classList.remove('is-open');
                        document.body.classList.remove('modal-open');
                        const isTimeBurst = this.activeMode === 'timeburst';

                        if (isGameInProgress) {
                            this.pendingAction = () => this.switchVariant(config.id, isTimeBurst, true);
                            document.getElementById('confirm-restart-modal').classList.add('is-open');
                            document.body.classList.add('modal-open');
                        } else {
                            this.switchVariant(config.id, isTimeBurst);
                        }
                    };
                    container.appendChild(button);
                });
            },

            switchVariant(variantId, isTimeBurst, isNewGame = false) {
                if (this.currentGameInstance) {
                    this.currentGameInstance.stopTimer();
                }
                const gameContainer = document.getElementById('game-container');
                gameContainer.style.transition = 'opacity 0.25s ease-in-out';
                gameContainer.style.opacity = '0';

                if (this.currentGameInstance && !isNewGame) {
                    this.gameStates[this.activeVariantId + (this.currentGameInstance.isTimeBurst ? '_timeburst' : '_classic')] = this.currentGameInstance.getState();
                }

                setTimeout(() => {
                    this.activeVariantId = variantId;
                    const variantConfig = variantConfigs[variantId];
                    const themeConfig = themeConfigs[variantConfig.themeId];
                    applyTheme(variantConfig.themeId);

                    const gameStateKey = variantId + (isTimeBurst ? '_timeburst' : '_classic');
                    const savedState = isNewGame ? null : this.gameStates[gameStateKey];
                    
                    if (isNewGame) {
                        delete this.gameStates[gameStateKey];
                    }

                    this.currentGameInstance = new Game(variantConfig, themeConfig, isTimeBurst, savedState);
                    
                    const editionDisplay = document.getElementById('current-edition-display');
                    let timeBurstText = isTimeBurst ? ' - <span style="color: var(--accent);">Time Burst</span>' : '';
                    editionDisplay.innerHTML = 'Now Playing: ' + variantConfig.name + timeBurstText;
                    
                    gameContainer.style.opacity = '1';
                }, 250);
            },
            
            resetCurrentVariant() {
                if (this.currentGameInstance) {
                    this.currentGameInstance.stopTimer();
                }
                this.switchVariant(this.activeVariantId, this.currentGameInstance.isTimeBurst, true);
            },
            
            setupGlobalEventListeners() {
                const editionModal = document.getElementById('edition-select-modal');
                const confirmModal = document.getElementById('confirm-restart-modal');
                const toggleSwitch = document.getElementById('mode-toggle-switch');
                const classicText = document.getElementById('classic-text');
                const timeBurstText = document.getElementById('time-burst-text');

                document.getElementById('select-edition-btn').addEventListener('click', () => {
                    const isTimeBurst = this.currentGameInstance.isTimeBurst;
                    this.activeMode = isTimeBurst ? 'timeburst' : 'classic';
                    
                    if(isTimeBurst) {
                        toggleSwitch.classList.add('time-burst-active');
                        timeBurstText.style.color = 'var(--accent)';
                        classicText.style.color = 'var(--text-secondary)';
                    } else {
                        toggleSwitch.classList.remove('time-burst-active');
                        classicText.style.color = 'var(--text)';
                        timeBurstText.style.color = 'var(--text-secondary)';
                    }

                    const currentEditionId = this.currentGameInstance.config.id;
                    const editionButtons = document.querySelectorAll('#edition-options button');
                    editionButtons.forEach(btn => {
                        btn.classList.remove('edition-selected');
                        if (btn.dataset.editionId === currentEditionId) {
                            btn.classList.add('edition-selected');
                        }
                    });

                    editionModal.classList.add('is-open');
                    document.body.classList.add('modal-open');
                });

                toggleSwitch.addEventListener('click', () => {
                    toggleSwitch.classList.toggle('time-burst-active');
                    this.activeMode = toggleSwitch.classList.contains('time-burst-active') ? 'timeburst' : 'classic';
                    if (this.activeMode === 'timeburst') {
                        timeBurstText.style.color = 'var(--accent)';
                        classicText.style.color = 'var(--text-secondary)';
                    } else {
                        classicText.style.color = 'var(--text)';
                        timeBurstText.style.color = 'var(--text-secondary)';
                    }
                });
                
                document.getElementById('close-edition-select-btn').addEventListener('click', () => { editionModal.classList.remove('is-open'); document.body.classList.remove('modal-open'); });

                document.getElementById('rules-btn').addEventListener('click', () => { this.currentGameInstance.DOMElements.rules_modal.classList.add('is-open'); document.body.classList.add('modal-open'); });

                document.getElementById('new-game-btn').addEventListener('click', () => {
                    const game = this.currentGameInstance;
                    if (game && game.gameStateManager.is('GAME_OVER')) {
                        this.resetCurrentVariant();
                        return;
                    }
                    const isGameInProgress = game && game.turnCount > 0;
                    
                    if (isGameInProgress) {
                        this.pendingAction = () => this.resetCurrentVariant();
                        confirmModal.classList.add('is-open');
                        document.body.classList.add('modal-open');
                    } else {
                        this.resetCurrentVariant();
                    }
                });

                document.getElementById('confirm-cancel-btn').addEventListener('click', () => {
                    this.pendingAction = null;
                    confirmModal.classList.remove('is-open');
                    document.body.classList.remove('modal-open');
                });
                
                document.getElementById('confirm-restart-btn').addEventListener('click', () => {
                    if (typeof this.pendingAction === 'function') {
                        this.pendingAction();
                    }
                    this.pendingAction = null;
                    confirmModal.classList.remove('is-open');
                    document.body.classList.remove('modal-open');
                });

                document.addEventListener('keydown', (e) => {
                    const game = this.currentGameInstance;
                    if (!game) return;

                    if (e.key === 'Escape') {
                        if (game.activeSuperpower) {
                             if (game.activeSuperpower === 'swapThem' && game.swapFirstCell) {
                                game.gridCells[game.swapFirstCell.r][game.swapFirstCell.c].classList.remove('pulse-animation');
                                game.swapFirstCell = null;
                            }
                            game.activeSuperpower = null;
                            game.updateSuperpowerButtonsUI();
                            game.gameStateManager.setState(game.firstPlacementCell ? 'AWAITING_PLACEMENT' : 'AWAITING_ROLL');
                        } else {
                           ['rules-modal', 'game-over-modal', 'exchange-modal', 'edition-select-modal', 'confirm-restart-modal', 'tutorial-modal'].forEach(id => {
                                const modal = document.getElementById(id);
                                if (modal?.classList.contains('is-open')) {
                                   modal.classList.remove('is-open');
                                   document.body.classList.remove('modal-open');
                                }
                           });
                        }
                    }
                    if (e.key === ' ' && game.gameStateManager.is('AWAITING_ROLL')) {
                        e.preventDefault();
                        game.handleRollDice();
                    }
                });
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
            gameManager.init();
        });
    })(); // <-- FIX 1: End of IIFE wrapper
    </script>
</body>
</html>
